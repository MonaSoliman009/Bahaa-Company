import * as tslib_1 from "tslib";
import { Pipe } from '@angular/core';
let UnAddedTagsPipe = class UnAddedTagsPipe {
    transform(tagsList, args) {
        const result = [];
        const { tagsAdded, config } = args;
        // if the tagsList is falsy, return empty list
        if (!tagsList) {
            return [];
        }
        // if we have to show selected tags (adds selected: true to every item (or nested tag))
        if (config.showTagsSelectedInDD) {
            tagsList = this.setSelectedTags(tagsList, config, tagsAdded);
        }
        // if we don't have to hide tags, send the tagsList (final, processed) back
        if (!config.hideAddedTags) {
            return tagsList;
        }
        /**
         * if we have to filter out the already selected tags in the dropdown, we'll filter these out
         * and thus the already selected tags won't go back in the results for dropdown
         */
        for (let i = 0, len = tagsList.length; i < len; ++i) {
            const currentTagItem = Object.assign({}, tagsList[i]); // making sure we're not modifying the original object here
            if (!this.isTagAlreadySelected(currentTagItem, tagsAdded, config)) { // if the tag to add isn't added already
                currentTagItem.tiSelected = false;
                if (config.nestedTagProperty && currentTagItem[config.nestedTagProperty]) {
                    currentTagItem[config.nestedTagProperty] = currentTagItem[config.nestedTagProperty].filter((tagItem) => {
                        return !this.isTagAlreadySelected(tagItem, tagsAdded, config);
                    });
                }
                result.push(currentTagItem);
            }
        }
        return result;
    }
    /**
     * @author Ahsan Ayaz
     * @desc Compares a tag against all the tags added based on config provided
     * @param currentTag - the tag to check if it exists in the selection
     * @param tagsAdded - an array of the tags added to the selection
     * @param config - the config provided to the Angular Tags Input component
     * @return boolean - if the tag is added already
     */
    isTagAlreadySelected(currentTag, tagsAdded, config) {
        return tagsAdded.find(tagItem => {
            let matchFound = false;
            matchFound = this.areTagsMatching(currentTag, tagItem, config);
            if (matchFound) {
                return true;
            }
            else if (tagItem[config.nestedTagProperty]) {
                return this.isTagAlreadySelected(currentTag, tagItem[config.nestedTagProperty], config);
            }
            return false;
        });
    }
    /**
     * @author Ahsan Ayaz
     * @desc Compares the two tags based on the identifier provided in the config
     * @param currentTag - the tag in the iteration to compare
     * @param tagItem - the tag (already selected) to compare with
     * @param config - the config provided to the Angular Tags Input component
     * @return boolean - if the tags passed are the same.
     */
    areTagsMatching(currentTag, tagItem, config) {
        if (typeof tagItem[config.identifier] === 'number') {
            // handling if the type of identifier is a number
            return tagItem[config.identifier] === +currentTag[config.identifier];
        }
        else if (typeof tagItem[config.identifier] === 'string' && typeof currentTag[config.identifier] === 'string') {
            // handling if the type of identifier is a string
            return tagItem[config.identifier].toLowerCase() === currentTag[config.identifier].toLowerCase();
        }
    }
    setSelectedTags(tags, config, tagsAdded, isSelected = null) {
        return tags.map(currentTag => {
            currentTag.tiSelected = !!this.isTagAlreadySelected(currentTag, tagsAdded, config);
            if (config.showTagsSelectedInDD && !!isSelected) {
                currentTag.tiSelected = true;
            }
            if (currentTag[config.nestedTagProperty] && currentTag[config.nestedTagProperty].length) {
                currentTag[config.nestedTagProperty] = this.setSelectedTags(currentTag[config.nestedTagProperty], config, tagsAdded, currentTag.tiSelected);
            }
            return currentTag;
        });
    }
};
UnAddedTagsPipe = tslib_1.__decorate([
    Pipe({
        name: 'unAddedTags'
    })
], UnAddedTagsPipe);
export { UnAddedTagsPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW4tYWRkZWQtdGFncy5waXBlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGlvbWVjaHMvYW5ndWxhci10YWdzLWlucHV0LyIsInNvdXJjZXMiOlsibGliL3VuLWFkZGVkLXRhZ3MucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFPcEQsSUFBYSxlQUFlLEdBQTVCLE1BQWEsZUFBZTtJQUMxQixTQUFTLENBQUMsUUFBb0IsRUFBRSxJQUE2RDtRQUMzRixNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFDbEIsTUFBTSxFQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUMsR0FBRyxJQUFJLENBQUM7UUFFakMsOENBQThDO1FBQzlDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBRUQsdUZBQXVGO1FBQ3ZGLElBQUksTUFBTSxDQUFDLG9CQUFvQixFQUFFO1lBQy9CLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDOUQ7UUFFRCwyRUFBMkU7UUFDM0UsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUU7WUFDekIsT0FBTyxRQUFRLENBQUM7U0FDakI7UUFFRDs7O1dBR0c7UUFDSCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQ25ELE1BQU0sY0FBYyxxQkFBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFFLDJEQUEyRDtZQUNyRyxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSx3Q0FBd0M7Z0JBQzNHLGNBQWMsQ0FBQyxVQUFVLEdBQUcsS0FBSyxD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U0FBUyxFQUNULFVBQVUsQ0FBQyxVQUFVLENBQ3RCLENBQUM7YUFDSDtZQUNELE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUVGLENBQUE7QUFoR1ksZUFBZTtJQUgzQixJQUFJLENBQUM7UUFDSixJQUFJLEVBQUUsYUFBYTtLQUNwQixDQUFDO0dBQ1csZUFBZSxDQWdHM0I7U0FoR1ksZUFBZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQW5ndWxhclRhZ3NJbnB1dENvbmZpZyB9IGZyb20gJy4vdGFncy1pbnB1dC1pbnRlcmZhY2VzJztcblxuQFBpcGUoe1xuICBuYW1lOiAndW5BZGRlZFRhZ3MnXG59KVxuZXhwb3J0IGNsYXNzIFVuQWRkZWRUYWdzUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICB0cmFuc2Zvcm0odGFnc0xpc3Q6IEFycmF5PGFueT4sIGFyZ3M6IHt0YWdzQWRkZWQ6IEFycmF5PGFueT4sIGNvbmZpZzogQW5ndWxhclRhZ3NJbnB1dENvbmZpZ30pOiBhbnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHt0YWdzQWRkZWQsIGNvbmZpZ30gPSBhcmdzO1xuXG4gICAgLy8gaWYgdGhlIHRhZ3NMaXN0IGlzIGZhbHN5LCByZXR1cm4gZW1wdHkgbGlzdFxuICAgIGlmICghdGFnc0xpc3QpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIHRvIHNob3cgc2VsZWN0ZWQgdGFncyAoYWRkcyBzZWxlY3RlZDogdHJ1ZSB0byBldmVyeSBpdGVtIChvciBuZXN0ZWQgdGFnKSlcbiAgICBpZiAoY29uZmlnLnNob3dUYWdzU2VsZWN0ZWRJbkREKSB7XG4gICAgICB0YWdzTGlzdCA9IHRoaXMuc2V0U2VsZWN0ZWRUYWdzKHRhZ3NMaXN0LCBjb25maWcsIHRhZ3NBZGRlZCk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0byBoaWRlIHRhZ3MsIHNlbmQgdGhlIHRhZ3NMaXN0IChmaW5hbCwgcHJvY2Vzc2VkKSBiYWNrXG4gICAgaWYgKCFjb25maWcuaGlkZUFkZGVkVGFncykge1xuICAgICAgcmV0dXJuIHRhZ3NMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGlmIHdlIGhhdmUgdG8gZmlsdGVyIG91dCB0aGUgYWxyZWFkeSBzZWxlY3RlZCB0YWdzIGluIHRoZSBkcm9wZG93biwgd2UnbGwgZmlsdGVyIHRoZXNlIG91dFxuICAgICAqIGFuZCB0aHVzIHRoZSBhbHJlYWR5IHNlbGVjdGVkIHRhZ3Mgd29uJ3QgZ28gYmFjayBpbiB0aGUgcmVzdWx0cyBmb3IgZHJvcGRvd25cbiAgICAgKi9cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGFnc0xpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUYWdJdGVtID0gey4uLnRhZ3NMaXN0W2ldfTsgIC8vIG1ha2luZyBzdXJlIHdlJ3JlIG5vdCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCBoZXJlXG4gICAgICBpZiAoIXRoaXMuaXNUYWdBbHJlYWR5U2VsZWN0ZWQoY3VycmVudFRhZ0l0ZW0sIHRhZ3NBZGRlZCwgY29uZmlnKSkgeyAvLyBpZiB0aGUgdGFnIHRvIGFkZCBpc24ndCBhZGRlZCBhbHJlYWR5XG4gICAgICAgIGN1cnJlbnRUYWdJdGVtLnRpU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNvbmZpZy5uZXN0ZWRUYWdQcm9wZXJ0eSAmJiBjdXJyZW50VGFnSXRlbVtjb25maWcubmVzdGVkVGFnUHJvcGVydHldKSB7XG4gICAgICAgICAgY3VycmVudFRhZ0l0ZW1bY29uZmlnLm5lc3RlZFRhZ1Byb3BlcnR5XSA9IGN1cnJlbnRUYWdJdGVtW2NvbmZpZy5uZXN0ZWRUYWdQcm9wZXJ0eV0uZmlsdGVyKCh0YWdJdGVtKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaXNUYWdBbHJlYWR5U2VsZWN0ZWQodGFnSXRlbSwgdGFnc0FkZGVkLCBjb25maWcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRUYWdJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXV0aG9yIEFoc2FuIEF5YXpcbiAgICogQGRlc2MgQ29tcGFyZXMgYSB0YWcgYWdhaW5zdCBhbGwgdGhlIHRhZ3MgYWRkZWQgYmFzZWQgb24gY29uZmlnIHByb3ZpZGVkXG4gICAqIEBwYXJhbSBjdXJyZW50VGFnIC0gdGhlIHRhZyB0byBjaGVjayBpZiBpdCBleGlzdHMgaW4gdGhlIHNlbGVjdGlvblxuICAgKiBAcGFyYW0gdGFnc0FkZGVkIC0gYW4gYXJyYXkgb2YgdGhlIHRhZ3MgYWRkZWQgdG8gdGhlIHNlbGVjdGlvblxuICAgKiBAcGFyYW0gY29uZmlnIC0gdGhlIGNvbmZpZyBwcm92aWRlZCB0byB0aGUgQW5ndWxhciBUYWdzIElucHV0IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIGJvb2xlYW4gLSBpZiB0aGUgdGFnIGlzIGFkZGVkIGFscmVhZHlcbiAgICovXG4gIGlzVGFnQWxyZWFkeVNlbGVjdGVkKGN1cnJlbnRUYWcsIHRhZ3NBZGRlZCwgY29uZmlnOiBBbmd1bGFyVGFnc0lucHV0Q29uZmlnKSB7XG4gICAgcmV0dXJuIHRhZ3NBZGRlZC5maW5kKHRhZ0l0ZW0gPT4ge1xuICAgICAgbGV0IG1hdGNoRm91bmQgPSBmYWxzZTtcbiAgICAgIG1hdGNoRm91bmQgPSB0aGlzLmFyZVRhZ3NNYXRjaGluZyhjdXJyZW50VGFnLCB0YWdJdGVtLCBjb25maWcpO1xuICAgICAgaWYgKG1hdGNoRm91bmQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRhZ0l0ZW1bY29uZmlnLm5lc3RlZFRhZ1Byb3BlcnR5XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1RhZ0FscmVhZHlTZWxlY3RlZChjdXJyZW50VGFnLCB0YWdJdGVtW2NvbmZpZy5uZXN0ZWRUYWdQcm9wZXJ0eV0sIGNvbmZpZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGF1dGhvciBBaHNhbiBBeWF6XG4gICAqIEBkZXNjIENvbXBhcmVzIHRoZSB0d28gdGFncyBiYXNlZCBvbiB0aGUgaWRlbnRpZmllciBwcm92aWRlZCBpbiB0aGUgY29uZmlnXG4gICAqIEBwYXJhbSBjdXJyZW50VGFnIC0gdGhlIHRhZyBpbiB0aGUgaXRlcmF0aW9uIHRvIGNvbXBhcmVcbiAgICogQHBhcmFtIHRhZ0l0ZW0gLSB0aGUgdGFnIChhbHJlYWR5IHNlbGVjdGVkKSB0byBjb21wYXJlIHdpdGhcbiAgICogQHBhcmFtIGNvbmZpZyAtIHRoZSBjb25maWcgcHJvdmlkZWQgdG8gdGhlIEFuZ3VsYXIgVGFncyBJbnB1dCBjb21wb25lbnRcbiAgICogQHJldHVybiBib29sZWFuIC0gaWYgdGhlIHRhZ3MgcGFzc2VkIGFyZSB0aGUgc2FtZS5cbiAgICovXG4gIGFyZVRhZ3NNYXRjaGluZyhjdXJyZW50VGFnLCB0YWdJdGVtLCBjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIHRhZ0l0ZW1bY29uZmlnLmlkZW50aWZpZXJdID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gaGFuZGxpbmcgaWYgdGhlIHR5cGUgb2YgaWRlbnRpZmllciBpcyBhIG51bWJlclxuICAgICAgcmV0dXJuIHRhZ0l0ZW1bY29uZmlnLmlkZW50aWZpZXJdID09PSArY3VycmVudFRhZ1tjb25maWcuaWRlbnRpZmllcl07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFnSXRlbVtjb25maWcuaWRlbnRpZmllcl0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBjdXJyZW50VGFnW2NvbmZpZy5pZGVudGlmaWVyXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGhhbmRsaW5nIGlmIHRoZSB0eXBlIG9mIGlkZW50aWZpZXIgaXMgYSBzdHJpbmdcbiAgICAgIHJldHVybiB0YWdJdGVtW2NvbmZpZy5pZGVudGlmaWVyXS50b0xvd2VyQ2FzZSgpID09PSBjdXJyZW50VGFnW2NvbmZpZy5pZGVudGlmaWVyXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHNldFNlbGVjdGVkVGFncyh0YWdzLCBjb25maWc6IEFuZ3VsYXJUYWdzSW5wdXRDb25maWcsIHRhZ3NBZGRlZCwgaXNTZWxlY3RlZCA9IG51bGwpIHtcbiAgICByZXR1cm4gdGFncy5tYXAoY3VycmVudFRhZyA9PiB7XG4gICAgICBjdXJyZW50VGFnLnRpU2VsZWN0ZWQgPSAhIXRoaXMuaXNUYWdBbHJlYWR5U2VsZWN0ZWQoY3VycmVudFRhZywgdGFnc0FkZGVkLCBjb25maWcpO1xuICAgICAgaWYgKGNvbmZpZy5zaG93VGFnc1NlbGVjdGVkSW5ERCAmJiAhIWlzU2VsZWN0ZWQpIHtcbiAgICAgICAgY3VycmVudFRhZy50aVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50VGFnW2NvbmZpZy5uZXN0ZWRUYWdQcm9wZXJ0eV0gJiYgY3VycmVudFRhZ1tjb25maWcubmVzdGVkVGFnUHJvcGVydHldLmxlbmd0aCkge1xuICAgICAgICBjdXJyZW50VGFnW2NvbmZpZy5uZXN0ZWRUYWdQcm9wZXJ0eV0gPSB0aGlzLnNldFNlbGVjdGVkVGFncyhcbiAgICAgICAgICBjdXJyZW50VGFnW2NvbmZpZy5uZXN0ZWRUYWdQcm9wZXJ0eV0sXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIHRhZ3NBZGRlZCxcbiAgICAgICAgICBjdXJyZW50VGFnLnRpU2VsZWN0ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50VGFnO1xuICAgIH0pO1xuICB9XG5cbn1cbiJdfQ==