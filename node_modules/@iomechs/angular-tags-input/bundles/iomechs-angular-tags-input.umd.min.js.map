{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@iomechs/angular-tags-input/lib/un-added-tags.pipe.ts","ng://@iomechs/angular-tags-input/lib/angular-tags-input.service.ts","ng://@iomechs/angular-tags-input/lib/tag-input/tag-input.component.ts","ng://@iomechs/angular-tags-input/lib/constants.ts","ng://@iomechs/angular-tags-input/lib/dropdown-items-filter.pipe.ts","ng://@iomechs/angular-tags-input/lib/dropdown/dropdown.component.ts","ng://@iomechs/angular-tags-input/lib/angular-tags-input.component.ts","ng://@iomechs/angular-tags-input/lib/tag/tag.component.ts","ng://@iomechs/angular-tags-input/lib/keyboard-active-class/keyboard-active-class.directive.ts","ng://@iomechs/angular-tags-input/lib/angular-tags-input.module.ts"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__decorate","decorators","target","key","desc","d","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__read","o","m","Symbol","iterator","e","ar","next","done","push","value","error","__spread","concat","UnAddedTagsPipe","transform","tagsList","args","_this","result","tagsAdded","config","showTagsSelectedInDD","setSelectedTags","hideAddedTags","len","currentTagItem","isTagAlreadySelected","tiSelected","nestedTagProperty","filter","tagItem","currentTag","find","areTagsMatching","identifier","toLowerCase","tags","isSelected","map","Pipe","name","AngularTagsInputService","debugMode","findTagById","tagsData","tagId","nestedParentFound","setDebugMode","mode","log","logMessage","logLabel","console","findParent","tagsArray","getMainTagAfterAdding","tagAdded","nestedTagParentProp","parentTag","parentTagChildren","childrensSelected","Injectable","providedIn","TagInputComponent","inputClass","disabled","valueChanged","EventEmitter","inputFocused","inputBlurred","tagEntered","tagInputForm","FormGroup","tagInputVal","FormControl","ngOnInit","get","valueChanges","pipe","debounceTime","distinctUntilChanged","subscribe","lastValueEmitted","emit","ngOnChanges","changes","undefined","currentValue","disable","enable","emitInputFocused","searchTerm","onEnterKeyPress","onlyFromAutoComplete","tagName","inputEl","nativeElement","_a","displayProperty","newTag","resetInput","emitInputBlurred","$event","tslib_1.__decorate","Input","Output","ViewChild","static","Component","selector","template","KEY_CODES","DropdownItemsFilterPipe","tagItems","tslib_1.__spread","item","getFilteredItem","includes","childItems","nestedItem","DropdownComponent","tagsInputService","listItems","inputVal","itemAdded","itemClicked","dropdownItemsFilter","identifierSeparator","itemsMap","Map","dropDownTemplate","defaultTagOptionTemplate","context","items","tagsLoading","fns","onItemClicked","bind","keyboardEventsManager","ListKeyManager","populateItemsMap","ddIdPrefix","getRandomString","firstChange","filterItems","Math","random","toString","substring","prefix","index","newPrefix","tiIdentifier","stopImmediatePropagation","handleKeyUp","event","isKeyDown","isKeyUp","isKeyEnter","setActiveElement","activeItem","keyCode","DOWN_ARROW","UP_ARROW","ENTER","previousActiveItem","tslib_1.__assign","setNextActiveElement","setPreviousActiveElement","currentActiveItem","tiKeyboardActive","setFirstItemActive","keyIdentifier","treeItems","keyIdentifierArr","split","splice","join","keys","RegExp","test","findIndex","id","setActiveElementRecursively","findNextParent","nextIdentifier","nextIdArr","setActiveItem","findPrevousParentLastChild","prevItemIdentifier","isOnlyItem","prevIdArr","indexOf","AngularTagsInputComponent","sso","tagsService","tagItemTemplate","required","tagRemoved","defaultConfig","defaultClass","additionalClasses","placeholder","hideTags","maxItems","keyboardActiveClass","dropdownOverlayPosition","offsetY","originX","originY","overlayX","overlayY","unAddedTagsPipe","keyEvent","inputKeyPress","isInputFocused","previousValue","dropdownShownYet","showDropdown","onFocusChange","val","hideDDOnBlur","setTimeout","hideDropdown","onInputValueChanged","ddScrollStrategy","reposition","writeValue","Array","isArray","tag","selectRelatedTags","registerOnChange","fn","onChange","validate","control","onInputFocus","clearInputOnFocus","tagInput","setValue","clearTagsOnFocus","recentTags","isDropdownOpen","removeKeyboardSelection","ngAfterViewInit","warn","Error","addTag","removeTag","toggleSelectionOnClick","removeTagSelection","ignoreChildren","ignoreParent","tagCloseClicked","showParentTagsOnly","parentTag_1","childrenCountProperty","registerOnTouched","dropdown","ScrollStrategyOptions","HostListener","providers","getAngularTagsInputValueAccessor","getAngularTagsInputValidatorsProvider","encapsulation","ViewEncapsulation","None","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","multi","NG_VALIDATORS","TagComponent","tagClass","closeClicked","defaultTagItemTemplate","KeyboardActiveClassDirective","el","cdRef","isKeyboardActiveItem","tiKeyboardActiveClass","simpleChanges","evaluateClassApplication","classList","add","scrollIntoView","remove","markForCheck","ElementRef","ChangeDetectorRef","Directive","AngularTagsInputModule","NgModule","declarations","imports","CommonModule","FormsModule","ReactiveFormsModule","OverlayModule","exports"],"mappings":";;;;;;;;;;;;;;oFA6BO,IAAIA,EAAW,WAQlB,OAPAA,EAAWC,OAAOC,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAII,KADTL,EAAIG,UAAUF,GACOJ,OAAOS,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,IAE9E,OAAON,IAEKU,MAAMC,KAAMP,YAezB,SAASQ,EAAWC,EAAYC,EAAQC,EAAKC,GAChD,IAA2HC,EAAvHC,EAAId,UAAUC,OAAQc,EAAID,EAAI,EAAIJ,EAAkB,OAATE,EAAgBA,EAAOlB,OAAOsB,yBAAyBN,EAAQC,GAAOC,EACrH,GAAuB,iBAAZK,SAAoD,mBAArBA,QAAQC,SAAyBH,EAAIE,QAAQC,SAAST,EAAYC,EAAQC,EAAKC,QACpH,IAAK,IAAId,EAAIW,EAAWR,OAAS,EAAGH,GAAK,EAAGA,KAASe,EAAIJ,EAAWX,MAAIiB,GAAKD,EAAI,EAAID,EAAEE,GAAKD,EAAI,EAAID,EAAEH,EAAQC,EAAKI,GAAKF,EAAEH,EAAQC,KAASI,GAChJ,OAAOD,EAAI,GAAKC,GAAKrB,OAAOyB,eAAeT,EAAQC,EAAKI,GAAIA,EA+DzD,SAASK,EAAOC,EAAGtB,GACtB,IAAIuB,EAAsB,mBAAXC,QAAyBF,EAAEE,OAAOC,UACjD,IAAKF,EAAG,OAAOD,EACf,IAAmBN,EAAYU,EAA3B3B,EAAIwB,EAAEjB,KAAKgB,GAAOK,EAAK,GAC3B,IACI,WAAc,IAAN3B,GAAgBA,KAAM,MAAQgB,EAAIjB,EAAE6B,QAAQC,MAAMF,EAAGG,KAAKd,EAAEe,OAExE,MAAOC,GAASN,EAAI,CAAEM,MAAOA,GACjC,QACQ,IACQhB,IAAMA,EAAEa,OAASN,EAAIxB,EAAU,SAAIwB,EAAEjB,KAAKP,GAE1D,QAAkB,GAAI2B,EAAG,MAAMA,EAAEM,OAE7B,OAAOL,EAGJ,SAASM,IACZ,IAAK,IAAIN,EAAK,GAAI5B,EAAI,EAAGA,EAAIE,UAAUC,OAAQH,IAC3C4B,EAAKA,EAAGO,OAAOb,EAAOpB,UAAUF,KACpC,OAAO4B,mBCpIX,SAAAQ,KAgGA,OA/FEA,EAAA/B,UAAAgC,UAAA,SAAUC,EAAsBC,GAAhC,IAAAC,EAAA/B,KACQgC,EAAS,GACRC,EAAAH,EAAAG,UAAWC,EAAAJ,EAAAI,OAGlB,IAAKL,EACH,MAAO,GAST,GALIK,EAAOC,uBACTN,EAAW7B,KAAKoC,gBAAgBP,EAAUK,EAAQD,KAI/CC,EAAOG,cACV,OAAOR,EAOT,IAAK,IAAItC,EAAI,EAAG+C,EAAMT,EAASnC,OAAQH,EAAI+C,IAAO/C,EAAG,CACnD,IAAMgD,EAAcrD,EAAA,GAAO2C,EAAStC,IAC/BS,KAAKwC,qBAAqBD,EAAgBN,EAAWC,KACxDK,EAAeE,YAAa,EACxBP,EAAOQ,mBAAqBH,EAAeL,EAAOQ,qBACpDH,EAAeL,EAAOQ,mBAAqBH,EAAeL,EAAOQ,mBAAmBC,QAAO,SAACC,GAC1F,OAAQb,EAAKS,qBAAqBI,EAASX,EAAWC,OAG1DF,EAAOV,KAAKiB,IAGhB,OAAOP,GAWTL,EAAA/B,UAAA4C,qBAAA,SAAqBK,EAAYZ,EAAWC,GAA5C,IAAAH,EAAA/B,KACE,OAAOiC,EAAUa,MAAK,SAAAF,GAGpB,QADab,EAAKgB,gBAAgBF,EAAYD,EAASV,MAG5CU,EAAQV,EAAOQ,oBACjBX,EAAKS,qBAAqBK,EAAYD,EAAQV,EAAOQ,mBAAoBR,OActFP,EAAA/B,UAAAmD,gBAAA,SAAgBF,EAAYD,EAASV,GACnC,MAA0C,iBAA/BU,EAAQV,EAAOc,YAEjBJ,EAAQV,EAAOc,eAAiBH,EAAWX,EAAOc,YACV,iBAA/BJ,EAAQV,EAAOc,aAAqE,iBAAlCH,EAAWX,EAAOc,YAE7EJ,EAAQV,EAAOc,YAAYC,gBAAkBJ,EAAWX,EAAOc,YAAYC,mBAF7E,GAMTtB,EAAA/B,UAAAwC,gBAAA,SAAgBc,EAAMhB,EAAgCD,EAAWkB,GAAjE,IAAApB,EAAA/B,KACE,YAD+D,IAAAmD,IAAAA,EAAA,MACxDD,EAAKE,KAAI,SAAAP,GAad,OAZAA,EAAWJ,aAAeV,EAAKS,qBAAqBK,EAAYZ,EAAWC,GACvEA,EAAOC,sBAA0BgB,IACnCN,EAAWJ,YAAa,GAEtBI,EAAWX,EAAOQ,oBAAsBG,EAAWX,EAAOQ,mBAAmBhD,SAC/EmD,EAAWX,EAAOQ,mBAAqBX,EAAKK,gBAC1CS,EAAWX,EAAOQ,mBAClBR,EACAD,EACAY,EAAWJ,aAGRI,MA5FAlB,EAAe1B,EAAA,CAH3BoD,EAAAA,KAAK,CACJC,KAAM,iBAEK3B,mBCCX,SAAA4B,IADAvD,KAAAwD,WAAY,SAWZD,EAAA3D,UAAA6D,YAAA,SAAYC,EAAUC,EAAOzB,GAC3B,IAAK,IAAI3C,EAAI,EAAG+C,EAAMoB,EAAShE,OAAQH,EAAI+C,IAAO/C,EAAG,CAEnD,GAAImE,EAASnE,GAAG2C,EAAOc,aAAeW,EACpC,OAAOD,EAASnE,GAElB,GAAImE,EAASnE,GAAG2C,EAAOQ,mBAAoB,CACzC,IAAMkB,EAAoB5D,KAAKyD,YAAYC,EAASnE,GAAG2C,EAAOQ,mBAAoBiB,EAAOzB,GACzF,GAAI0B,EACF,OAAOA,KAMfL,EAAA3D,UAAAiE,aAAA,SAAaC,GACX9D,KAAKwD,UAAYM,GAGnBP,EAAA3D,UAAAmE,IAAA,SAAIC,EAAiBC,QAAA,IAAAA,IAAAA,EAAA,IACdjE,KAAKwD,WAGVU,QAAQH,IAAIE,EAAUD,IAGxBT,EAAA3D,UAAAuE,WAAA,SAAWC,EAAWxB,EAASV,GAC7B,IAAK,IAAI3C,EAAI,EAAG+C,EAAM8B,EAAU1E,OAAQH,EAAI+C,IAAO/C,EAAG,CAEpD,GAAI6E,EAAU7E,GAAG2C,EAAOc,aAAeJ,EAAQV,EAAOc,YACpD,OAAOoB,EAAU7E,GAEnB,GAAI6E,EAAU7E,GAAG2C,EAAOQ,mBAAoB,CAC1C,IAAMkB,EAAoB5D,KAAKmE,WAAWC,EAAU7E,GAAG2C,EAAOQ,mBAAoBE,EAASV,GAC3F,GAAI0B,EACF,OAAOA,KAMfL,EAAA3D,UAAAyE,sBAAA,SAAsBD,EAAWE,EAAUpB,EAAMhB,GAC/C,GAAIoC,EAASpC,EAAOqC,qBAAsB,CACxC,IAAMC,EAAYxE,KAAKyD,YACrBW,EACAE,EAASpC,EAAOqC,qBAChBrC,GAEF,IAAKsC,EACH,OAEF,IAAMC,EAAoBD,EAAUtC,EAAOQ,mBAAmBhD,OACxDgF,EAAoBF,EAAUtC,EAAOQ,mBAAmBC,QAAO,SAACC,GAEpE,QAASA,EAAQH,cAChB/C,OACH,GAAI+E,EAAoB,GAAKC,EAAoB,GAAKA,IAAsBD,EAE1E,OADAD,EAAU/B,YAAa,EAClB+B,EAAUtC,EAAOqC,qBAGbvE,KAAKqE,sBAAsBD,EAAWI,EAAWtB,EAAMhB,GAFvDsC,EAMb,OAAOF,wGA7EEf,EAAuBtD,EAAA,CAHnC0E,EAAAA,WAAW,CACVC,WAAY,UAEDrB,mBCiBX,SAAAsB,IAZS7E,KAAA8E,WAAa,UAEb9E,KAAA+E,UAAW,EACV/E,KAAAgF,aAAe,IAAIC,EAAAA,aACnBjF,KAAAkF,aAAe,IAAID,EAAAA,aACnBjF,KAAAmF,aAAe,IAAIF,EAAAA,aACnBjF,KAAAoF,WAAa,IAAIH,EAAAA,aAE3BjF,KAAAqF,aAAe,IAAIC,EAAAA,UAAU,CAC3BC,YAAa,IAAIC,EAAAA,YAAY,MA0EjC,OArEEX,EAAAjF,UAAA6F,SAAA,WAAA,IAAA1D,EAAA/B,KACEA,KAAKqF,aAAaK,IAAI,eACnBC,aACAC,KACCC,EAAAA,aAAa,KACbC,EAAAA,wBAEDC,WAAU,SAACxE,GACVQ,EAAKiE,iBAAmBzE,EACxBQ,EAAKiD,aAAaiB,KAAK1E,OAI7BsD,EAAAjF,UAAAsG,YAAA,SAAYC,QACeC,IAArBD,EAAQpB,YAC4B,IAAlCoB,EAAQpB,SAASsB,aACnBrG,KAAKqF,aAAaK,IAAI,eAAeY,UAErCtG,KAAKqF,aAAaK,IAAI,eAAea,WAS3C1B,EAAAjF,UAAA4G,iBAAA,WACE,IAAIxG,KAAK+E,SAAT,CAGA,IAAM0B,EAAazG,KAAKqF,aAAaK,IAAI,eAAenE,MACxDvB,KAAKkF,aAAae,KAAKQ,GAEnBzG,KAAKgG,mBAAqBS,IAC5BzG,KAAKgF,aAAaiB,KAAKQ,GACvBzG,KAAKgG,iBAAmBS,KAS5B5B,EAAAjF,UAAA8G,gBAAA,iBACE,IAAI1G,KAAKkC,OAAOyE,qBAAhB,CAGA,IAAMC,EAAU5G,KAAK6G,QAAQC,cAAcvF,MAC3CvB,KAAKoF,WAAWa,OAAIc,EAAA,IACjB/G,KAAKkC,OAAO8E,iBAAkBJ,EAC/BG,EAAC/G,KAAKkC,OAAOc,YAAa4D,EAAQ3D,cAClC8D,EAAAE,QAAQ,MAEVjH,KAAKkH,eAOPrC,EAAAjF,UAAAsH,WAAA,WACElH,KAAK6G,QAAQC,cAAcvF,MAAQ,IAGrCsD,EAAAjF,UAAAuH,iBAAA,SAAiBC,GACfpH,KAAKmF,aAAac,KAAKmB,IAjFhBC,EAAAA,CAARC,EAAAA,0CACQD,EAAAA,CAARC,EAAAA,sCACQD,EAAAA,CAARC,EAAAA,wCACSD,EAAAA,CAATE,EAAAA,6CACSF,EAAAA,CAATE,EAAAA,6CACSF,EAAAA,CAATE,EAAAA,6CACSF,EAAAA,CAATE,EAAAA,2CACuCF,EAAAA,CAAvCG,EAAAA,UAAU,UAAW,CAAEC,QAAQ,mCARrB5C,EAAiB5E,EAAA,CAL7ByH,EAAAA,UAAU,CACTC,SAAU,eACVC,SAAA,ooBAGW/C,MCVAgD,EACC,YADDA,EAED,UAFCA,EAGJ,QAHIA,EAIH,sBCEV,SAAAC,KAsCA,OApCEA,EAAAlI,UAAAgC,UAAA,SAAUmG,EAAsC7F,EAAgCuE,GAAhF,IAAA1E,EAAA/B,KACE,YADQ,IAAA+H,IAAAA,EAAA,SAAsE,IAAAtB,IAAAA,EAAA,IACzEA,EAGEuB,EAAID,GACR3E,KAAI,SAAC6E,GAAyB,OAAAlG,EAAKmG,gBAAehJ,EAAA,GAAK+I,GAAO/F,EAAQuE,MACtE9D,QAAO,SAAAsF,GAAQ,QAAEA,KAJXF,GAOXD,EAAAlI,UAAAsI,gBAAA,SAAgBD,EAAsB/F,EAAgCuE,SAAtE1E,EAAA/B,KACE,QADoE,IAAAyG,IAAAA,EAAA,IACjD,KAAfA,EACF,OAAOwB,EAGT,GAAIA,EAAK/F,EAAO8E,iBAAiB/D,cAAckF,SAAS1B,EAAWxD,eACjE,OAAOgF,EAGT,GAAIA,EAAK/F,EAAOQ,mBAAoB,CAClC,IAAM0F,EAAaH,EAAK/F,EAAOQ,mBAAmBU,KAAI,SAAAiF,GACpD,OAAOtG,EAAKmG,gBAAgBG,EAAYnG,EAAQuE,MAC/C9D,QAAO,SAAA0F,GAAc,QAAEA,KAI1B,GAFUD,EAAW1I,OAAS,EAG5B,OAAAR,EAAA,GACK+I,IAAIlB,EAAA,IACN7E,EAAOQ,mBAAiBjB,EAAO2G,GAAUrB,IAKhD,OAAO,MAnCEe,EAAuB7H,EAAA,CAHnCoD,EAAAA,KAAK,CACJC,KAAM,yBAEKwE,mBCuCX,SAAAQ,EACUC,GAAAvI,KAAAuI,iBAAAA,EAhBDvI,KAAAwI,UAAmC,GACnCxI,KAAAyI,SAAW,GAIVzI,KAAA0I,UAAY,IAAIzD,EAAAA,aAChBjF,KAAA2I,YAAc,IAAI1D,EAAAA,aAE5BjF,KAAA4I,oBAAsB,IAAId,EAI1B9H,KAAA6I,oBAAsB,KAEtB7I,KAAA8I,SAA6B,IAAIC,IAwPnC,OAnPET,EAAA1I,UAAA6F,SAAA,WACOzF,KAAKgJ,mBAERhJ,KAAKgJ,iBAAmBhJ,KAAKiJ,0BAE/BjJ,KAAKkJ,QAAU,CACbC,MAAK1H,EAAMzB,KAAKwI,WAChBtG,OAAQlC,KAAKkC,OACbkH,YAAapJ,KAAKoJ,YAClBC,IAAK,CACHC,cAAetJ,KAAKsJ,cAAcC,KAAKvJ,QAG3CA,KAAKwJ,sBAAwB,IAAIC,EAAAA,eAAchI,EAAKzB,KAAKwI,YACzDxI,KAAK0J,iBAAiB1J,KAAKwI,WAC3BxI,KAAK2J,WAAa3J,KAAK4J,kBACvB5J,KAAKuI,iBAAiBxE,IAAI/D,KAAK8I,SAAU,8BAG3CR,EAAA1I,UAAAsG,YAAA,SAAYC,GACNA,EAAQqC,YAAcrC,EAAQqC,UAAUqB,cAE1C7J,KAAK8J,YAAY9J,KAAKyI,SAAUtC,EAAQqC,UAAUnC,cAClDrG,KAAK0J,iBAAiBvD,EAAQqC,UAAYrC,EAAQqC,UAAUnC,aAAerG,KAAKwI,YAIhFrC,EAAQsC,WAAatC,EAAQsC,SAASoB,cAGtC7J,KAAK8J,YAAY3D,EAAQsC,SAASpC,cAClCrG,KAAK0J,iBAAiBvD,EAAQqC,UAAYrC,EAAQqC,UAAUnC,aAAerG,KAAKwI,aAWpFF,EAAA1I,UAAAkK,YAAA,SAAYrD,EAA4B0C,QAA5B,IAAA1C,IAAAA,EAAazG,KAAKyI,eAAU,IAAAU,IAAAA,EAAQnJ,KAAKwI,WACnDxI,KAAKkJ,QAAQC,MAAK1H,EAAOzB,KAAK4I,oBAAoBhH,UAChDuH,EACAnJ,KAAKkC,OACLuE,IAEFzG,KAAK2J,WAAa3J,KAAK4J,mBAGjBtB,EAAA1I,UAAAgK,gBAAR,WACE,OAAOG,KAAKC,SAASC,SAAS,IAAIC,UAAU,EAAG,IAAMH,KAAKC,SAASC,SAAS,IAAIC,UAAU,EAAG,KAG/F5B,EAAA1I,UAAA8J,iBAAA,SAAiBP,EAAOgB,GAAxB,IAAApI,EAAA/B,UAAwB,IAAAmK,IAAAA,EAAA,MACP,OAAXA,EACFA,EAAS,GAETA,GAAUnK,KAAK6I,oBAEjBM,EAAM/F,KAAI,SAAC6E,EAAMmC,GACf,IAAMC,EAAYF,EAASC,EAC3BnC,EAAKqC,aAAeD,EACpBtI,EAAK+G,SAASuB,GAAapC,EACvBA,EAAKlG,EAAKG,OAAOQ,oBAAsBuF,EAAKlG,EAAKG,OAAOQ,mBAAmBhD,QAC7EqC,EAAK2H,iBAAiBzB,EAAKlG,EAAKG,OAAOQ,mBAAoB2H,OAUjE/B,EAAA1I,UAAA0J,cAAA,SAAcrB,EAAsBb,QAAA,IAAAA,IAAAA,EAAA,MAC9BA,GACFA,EAAOmD,2BAETvK,KAAK2I,YAAY1C,KAAKgC,IAGxBK,EAAA1I,UAAA4K,YAAA,SAAYC,GAEV,GADAA,EAAMF,2BACDvK,KAAKwJ,sBAAV,CAGA,IAAMkB,EAAY1K,KAAK0K,UAAUD,GAC3BE,EAAU3K,KAAK2K,QAAQF,GACvBG,EAAa5K,KAAK4K,WAAWH,GAE/BC,GAAaC,EAEf3K,KAAK6K,iBAAiBJ,GAEtBG,GACA5K,KAAKwJ,sBAAsBsB,YAE3B9K,KAAK2I,YAAY1C,KACfjG,KAAKwJ,sBAAsBsB,cAKjCxC,EAAA1I,UAAA8K,UAAA,SAAUD,GAER,OAAOA,EAAMrK,MAAQyH,GAAwB4C,EAAMM,UAAYC,EAAAA,YAGjE1C,EAAA1I,UAAA+K,QAAA,SAAQF,GAEN,OAAOA,EAAMrK,MAAQyH,GAAsB4C,EAAMM,UAAYE,EAAAA,UAG/D3C,EAAA1I,UAAAgL,WAAA,SAAWH,GAET,OAAOA,EAAMrK,MAAQyH,GAAmB4C,EAAMM,UAAYG,EAAAA,OAG5D5C,EAAA1I,UAAAiL,iBAAA,SAAiBJ,GACf,IAAMC,EAAY1K,KAAK0K,UAAUD,GAC3BE,EAAU3K,KAAK2K,QAAQF,GACvBU,EAAqBC,EAAAA,GAAKpL,KAAKwJ,sBAAsBsB,YACvDJ,EACF1K,KAAKqL,qBAAqBF,EAAoBnL,KAAKwI,WAC1CmC,GACT3K,KAAKsL,yBAAyBH,EAAoBnL,KAAKwI,YAI3DF,EAAA1I,UAAAyL,qBAAA,SAAqBE,EAAmCpC,GAAxD,IAAApH,EAAA/B,KACQgD,EAAauI,EAAkBjB,aACrC,IAAKtH,EAGH,OAFAmG,EAAM,GAAGqC,kBAAmB,OAC5BxL,KAAKwJ,sBAAsBiC,qBAG7B,IACIC,EACAC,EACAvB,EAHEwB,EAAmB5I,EAAW6I,MAAM7L,KAAK6I,qBAI/C6C,EAAgBE,EAAiBlM,OAAS,EACxCsI,EAAI4D,GAAkBE,OAAO,EAAGF,EAAiBlM,OAAS,GAAGqM,KAAK/L,KAAK6I,qBACvE+C,EAAiB,IACnBD,EAAYxM,OAAO6M,KAAKhM,KAAK8I,UAAUnG,QAAO,SAAAvC,GAAO,OAAA,IAAI6L,OAAO,IAAIP,EAAgB3J,EAAK8G,qBAAuBqD,KAAK9L,OACtGV,SACbiM,EAAYxM,OAAO6M,KAAKhM,KAAK8I,UAAUnG,QAAO,SAAAvC,GAAO,OAAA,IAAI6L,OAAO,IAAIP,EAAa,KAAKQ,KAAK9L,QAE7FgK,EAAQuB,EAAUQ,WAAU,SAAAC,GAAM,OAAAA,IAAOpJ,QAC3B2I,EAAUjM,OAAS,EAC/BM,KAAKqM,4BAA4BrM,KAAKsM,eAAeV,GAAmB5L,KAAKwI,WAE7ExI,KAAKqM,4BAA4BV,EAAUvB,EAAQ,GAAIpK,KAAKwI,YAIhEF,EAAA1I,UAAA0M,eAAA,SAAeV,GACb,IAAIF,EACAC,EACJ,GAAgC,IAA5BC,EAAiBlM,OAAc,CACjC,IAAM6M,EAAiB,KAAIX,EAAiB,GAAK,GACjD,OAAI5L,KAAK8I,SAASyD,GACTA,EAEFX,EAAiB,GAE1B,IAAMY,EAAYxE,EAAI4D,GAAkBE,OAAO,EAAGF,EAAiBlM,OAAS,GAI5E,OAHA8M,EAAUA,EAAU9M,OAAS,GAAK,KAAK8M,EAAUA,EAAU9M,OAAS,GAAM,GAC1EgM,EAAgBc,EAAUT,KAAK/L,KAAK6I,sBACpC8C,EAAYxM,OAAO6M,KAAKhM,KAAK8I,UAAUnG,QAAO,SAAAvC,GAAO,OAAA,IAAI6L,OAAO,IAAIP,GAAiBQ,KAAK9L,OAC5EV,OACLiM,EAAU,GAEV3L,KAAKsM,eAAc7K,EAAKmK,EAAiBE,OAAO,EAAGF,EAAiBlM,OAAS,MAIxF4I,EAAA1I,UAAA0L,yBAAA,SAAyBC,EAAmCpC,GAA5D,IAAApH,EAAA/B,KACQgD,EAAauI,EAAkBjB,aACrC,IAAKtH,EAGH,OAFAmG,EAAMA,EAAMzJ,OAAS,GAAG8L,kBAAmB,OAC3CxL,KAAKwJ,sBAAsBiD,cAActD,EAAMA,EAAMzJ,OAAS,IAIhE,IACIgM,EACAC,EACAvB,EAHEwB,EAAmB5I,EAAW6I,MAAM7L,KAAK6I,qBAI/C6C,EAAgBE,EAAiBlM,OAAS,EACxCsI,EAAI4D,GAAkBE,OAAO,EAAGF,EAAiBlM,OAAS,GAAGqM,KAAK/L,KAAK6I,qBACvE+C,EAAiB,IACnBD,EAAYxM,OAAO6M,KAAKhM,KAAK8I,UAAUnG,QAAO,SAAAvC,GAAO,OAAA,IAAI6L,OAAO,IAAIP,EAAa,IAAI3J,EAAK8G,oBAAmB,MAAMqD,KAAK9L,OACzGV,SACbiM,EAAYxM,OAAO6M,KAAKhM,KAAK8I,UAAUnG,QAAO,SAAAvC,GAAO,OAAA,IAAI6L,OAAO,IAAIP,EAAa,KAAKQ,KAAK9L,OAE7FgK,EAAQuB,EAAUQ,WAAU,SAAAC,GAAM,OAAAA,IAAOpJ,KAChB,IAArB2I,EAAUjM,QAA0B,IAAV0K,EAC5BpK,KAAKqM,4BAA4BrM,KAAK0M,2BAA2Bd,EAAkB5I,GAAahD,KAAKwI,WAErGxI,KAAKqM,4BAA4BV,EAAUvB,EAAQ,GAAIpK,KAAKwI,YAIhEF,EAAA1I,UAAA8M,2BAAA,SAA2Bd,EAAkBe,GAA7C,IACMjB,EADN3J,EAAA/B,KAEQ4M,EAAyC,IAA5BhB,EAAiBlM,OAC9BmN,EAAcD,EAAUnL,EACxBmK,GACJ5D,EAAI4D,GAAkBE,OAAO,EAAGF,EAAiBlM,OAAS,GAC5DmN,EAAUA,EAAUnN,OAAS,GAAOkN,EAAa,KAAKC,EAAUA,EAAUnN,OAAS,GAAM,GAAMmN,EAAUA,EAAUnN,OAAS,GAC5HgM,EAAgBmB,EAAUd,KAAK/L,KAAK6I,qBACpC,IAAI8C,EAAYxM,OAAO6M,KAAKhM,KAAK8I,UAAUnG,QAAO,SAAAvC,GAAO,OAAA,IAAI6L,OAAO,IAAIP,EAAgB3J,EAAK8G,qBAAuBqD,KAAK9L,MAIzH,OAHKuL,EAAUjM,SACbiM,EAAYxM,OAAO6M,KAAKhM,KAAK8I,UAAUnG,QAAO,SAAAvC,GAAO,OAAA,IAAI6L,OAAO,IAAIP,EAAa,KAAKQ,KAAK9L,OAEzFuL,EAAUjM,QACmC,IAA3CiM,EAAUmB,QAAQH,GACbjB,EAEFC,EAAUA,EAAUjM,OAAS,GAC3BkM,EAAiBlM,OAAS,EAC5BM,KAAK0M,2BAA0BjL,EAAKmK,EAAiBE,OAAO,EAAGF,EAAiBlM,OAAS,IAAKiN,GAErGjB,EAAgBE,EAAiBG,KAAK/L,KAAK6I,sBAK/CP,EAAA1I,UAAAyM,4BAAA,SAA4BrJ,EAAYmG,GACtC,IAAK,IAAI5J,EAAI,EAAG+C,EAAM6G,EAAMzJ,OAAQH,EAAI+C,IAAO/C,EAC7C4J,EAAM5J,GAAGiM,kBAAmB,EACxBrC,EAAM5J,GAAG+K,eAAiBtH,IAC5BhD,KAAKwJ,sBAAwB,IAAIC,EAAAA,eAAchI,EAAK0H,IACpDA,EAAM5J,GAAGiM,kBAAmB,EAC5BxL,KAAKwJ,sBAAsBiD,cAActD,EAAM5J,KAE7C4J,EAAM5J,GAAGS,KAAKkC,OAAOQ,oBAAsByG,EAAM5J,GAAGS,KAAKkC,OAAOQ,mBAAmBhD,QACrFM,KAAKqM,4BAA4BrJ,EAAYmG,EAAM5J,GAAGS,KAAKkC,OAAOQ,8DAlP5Ca,KAjBnB8D,EAAAA,CAARC,EAAAA,sCACQD,EAAAA,CAARC,EAAAA,yCACQD,EAAAA,CAARC,EAAAA,wCACQD,EAAAA,CAARC,EAAAA,gDACQD,EAAAA,CAARC,EAAAA,2CACQD,EAAAA,CAARC,EAAAA,wCACSD,EAAAA,CAATE,EAAAA,0CACSF,EAAAA,CAATE,EAAAA,4CACwDF,EAAAA,CAAxDG,EAAAA,UAAU,2BAA4B,CAAEC,QAAQ,oDAVtCa,EAAiBrI,EAAA,CAL7ByH,EAAAA,UAAU,CACTC,SAAU,cACVC,SAAA,miCAGWU,mBCmDX,SAAAyE,EACmBC,EACTC,GADSjN,KAAAgN,IAAAA,EACThN,KAAAiN,YAAAA,EA1CDjN,KAAA0D,SAAuB,GACvB1D,KAAA+E,UAAW,EAEX/E,KAAAgJ,iBAAqC,KACrChJ,KAAAkN,gBAAoC,KACpClN,KAAAmN,UAAW,EACVnN,KAAAoN,WAAa,IAAInI,EAAAA,aACjBjF,KAAAsE,SAAW,IAAIW,EAAAA,aACfjF,KAAAgF,aAAe,IAAIC,EAAAA,aACnBjF,KAAA2I,YAAc,IAAI1D,EAAAA,aAE5BjF,KAAAkD,KAA8B,GAG9BlD,KAAAqN,cAAwC,CACtCC,aAAc,qBACdC,kBAAmB,GACnBvG,gBAAiB,QACjBhE,WAAY,KACZ2D,sBAAsB,EACtB6G,YAAa,SACbnL,eAAe,EACfK,kBAAmB,GACnBP,sBAAsB,EACtBsL,UAAU,EACVC,SAAU,KACVnJ,oBAAqB,GACrBoJ,oBAAqB,6CAGvB3N,KAAA4N,wBAA0B,CACxB,CAAEC,QAAS,GAAIC,QAAS,QAASC,QAAS,SAAUC,SAAU,QAASC,SAAU,OACjF,CAAEJ,SAAU,GAAIC,QAAS,QAASC,QAAS,MAAOC,SAAU,QAASC,SAAU,UAC/E,CAAEJ,QAAS,GAAIC,QAAS,MAAOC,QAAS,SAAUC,SAAU,MAAOC,SAAU,UAC7E,CAAEJ,SAAU,GAAIC,QAAS,MAAOC,QAAS,MAAOC,SAAU,MAAOC,SAAU,WAK7EjO,KAAAkO,gBAAkB,IAAIvM,EAgZxB,OAxYEoL,EAAAnN,UAAAuO,SAAA,SAAS1D,GACPzK,KAAKoO,cAAc3D,IAGrBsC,EAAAnN,UAAAsG,YAAA,SAAYC,GAEV,GAAKA,EAAQzC,UAAa1D,KAAKqO,iBAM1BlI,EAAQzC,SAAS4K,gBACpBnI,EAAQzC,SAAS4K,cAAgB,IAKjCnI,EAAQzC,UAAYyC,EAAQzC,SAAS2C,eAAiBF,EAAQzC,SAAS4K,gBACnEnI,EAAQzC,SAASmG,aACrB,CAEA,GAAI1D,EAAQzC,SAAS2C,aAAa3G,SAAWyG,EAAQzC,SAAS4K,cAAc5O,QAAYM,KAAKuO,iBAC3F,OAAOvO,KAAKwO,aAAarI,EAAQzC,SAAS2C,cAG5C,GAA8C,IAA1CF,EAAQzC,SAAS4K,cAAc5O,OACjC,OAOF,IAAK,IAAIH,EAAI,EAAG+C,EAAM6D,EAAQzC,SAAS2C,aAAa3G,OAAQH,EAAI+C,IAAO/C,EACrE,GAAI4G,EAAQzC,SAAS2C,aAAa9G,GAAGS,KAAKkC,OAAOc,cAAgBmD,EAAQzC,SAAS4K,cAAc/O,GAAGS,KAAKkC,OAAOc,YAE7G,OAAOhD,KAAKwO,aAAarI,EAAQzC,SAAS2C,gBAMlD0G,EAAAnN,UAAA6O,cAAA,SAAcC,GAAd,IAAA3M,EAAA/B,KACEA,KAAKqO,eAAiBK,GACjBA,GAAO1O,KAAKkC,OAAOyM,cACtBC,YAAW,WACT7M,EAAK8M,iBACJ,MAIP9B,EAAAnN,UAAAkP,oBAAA,SAAoBJ,GAClB1O,KAAKyI,SAAWiG,EAChB1O,KAAKgF,aAAaiB,KAAKyI,IAGzB3B,EAAAnN,UAAA6F,SAAA,WACEzF,KAAKkC,OAAMhD,EAAA,GACNc,KAAKqN,cACLrN,KAAKkC,QAEVlC,KAAK+O,iBAAmB/O,KAAKgN,IAAIgC,cAQnCjC,EAAAnN,UAAAqP,WAAA,SAAW/L,GAAX,IAAAnB,EAAA/B,KACEkD,EAAOA,GAAc,GACrBA,EAAOgM,MAAMC,QAAQjM,GAAQA,EAAO,CAACA,GACrClD,KAAKkD,KAAOA,EAAKE,KAAI,SAACgM,SACpB,OAAAlQ,EAAA,GACKkQ,IAAGrI,EAAA,IAEHhF,EAAKG,OAAOc,YAAaoM,EAAIrN,EAAKG,OAAOc,YAC1C+D,EAAChF,EAAKG,OAAO8E,iBAAkBoI,EAAIrN,EAAKG,OAAO8E,wBAKjDhH,KAAKkC,OAAOC,sBACdyM,YAAW,WACT7M,EAAKmB,KAAKE,KAAI,SAACgM,GACbrN,EAAKsN,kBAAkBD,UAU/BrC,EAAAnN,UAAA0P,iBAAA,SAAkBC,GAChBvP,KAAKwP,SAAWD,GAQlBxC,EAAAnN,UAAA6P,SAAA,SAASC,GACP,OAAsB,IAAlB1P,KAAKmN,SACA,KAECuC,EAAQnO,OAASmO,EAAQnO,MAAM7B,OAAU,KAAO,CACxDyN,UAAU,IAQdJ,EAAAnN,UAAA+P,aAAA,WACM3P,KAAKkC,OAAO0N,oBACyB,KAAnC5P,KAAK6P,SAAS7J,kBAChBhG,KAAK6P,SAASxK,aAAaK,IAAI,eAAeoK,SAAS,IAEzD9P,KAAK6P,SAAS3I,cAEZlH,KAAKkC,OAAO6N,mBACd/P,KAAKkD,KAAKxD,OAAS,GAErBM,KAAKwO,eACLxO,KAAKyO,eAAc,IAOrB1B,EAAAnN,UAAA4O,aAAA,SAAawB,QAAA,IAAAA,IAAAA,EAAA,MACShQ,KAAKkO,gBAAgBtM,UACrCoO,GAA0BhQ,KAAK0D,SACjC,CACEzB,UAAWjC,KAAKkD,KAChBhB,OAAQlC,KAAKkC,SAGDxC,SACdM,KAAKiQ,gBAAiB,GAEnBjQ,KAAKuO,mBACRvO,KAAKuO,kBAAmB,IAQ5BxB,EAAAnN,UAAAiP,aAAA,WACE7O,KAAKiQ,gBAAiB,EACtBjQ,KAAK0D,SAAW1D,KAAKkQ,wBAAwBlQ,KAAK0D,WAGpDqJ,EAAAnN,UAAAsQ,wBAAA,SAAwB/G,GAAxB,IAAApH,EAAA/B,KACE,OAAOmJ,EAAM/F,KAAI,SAACgM,GAIhB,OAHIA,EAAIrN,EAAKG,OAAOQ,oBAAsB0M,EAAIrN,EAAKG,OAAOQ,mBAAmBhD,SAC3E0P,EAAIrN,EAAKG,OAAOQ,mBAAqBX,EAAKmO,wBAAwBd,EAAIrN,EAAKG,OAAOQ,qBAEpFxD,EAAA,GACKkQ,EAAG,CACN5D,kBAAkB,QAKxBuB,EAAAnN,UAAAuQ,gBAAA,WAIE,IAHMnQ,KAAKkC,QAAWlC,KAAKwP,UACzBtL,QAAQkM,KAAK,sEAEXpQ,KAAKkC,OAAOQ,oBAET1C,KAAKkC,OAAOqC,oBAEf,MAAM,IAAI8L,MAAM,qJAWtBtD,EAAAnN,UAAA0Q,OAAA,SAAOlB,GAAP,IAAArN,EAAA/B,KACMA,KAAKkC,OAAOC,uBACdiN,EAAI3M,YAAa,GAEfzC,KAAKkC,OAAOwL,SAAW,GAAK1N,KAAKkD,KAAKxD,SAAWM,KAAKkC,OAAOwL,UAG5D1N,KAAKkD,KAAKJ,MAAK,SAAAF,GAAW,OAAAA,EAAQb,EAAKG,OAAOc,cAAgBoM,EAAIrN,EAAKG,OAAOc,iBACjFhD,KAAKkD,KAAIzB,EAAOzB,KAAKkD,KAAI,CAAEkM,IAC3BpP,KAAKwP,SACHxP,KAAKkD,QAUX6J,EAAAnN,UAAA2Q,UAAA,SAAUnB,GAAV,IAAArN,EAAA/B,KACEA,KAAKkD,KAAOlD,KAAKkD,KAAKP,QAAO,SAACC,GAAY,OAAAA,EAAQb,EAAKG,OAAOc,cAAgBoM,EAAIrN,EAAKG,OAAOc,eAErE,IAArBhD,KAAKkD,KAAKxD,SACZM,KAAK6P,SAAS3I,aACdlH,KAAKgF,aAAaiB,KAAK,KAEzBjG,KAAKwP,SACHxP,KAAKkD,OAST6J,EAAAnN,UAAA0J,cAAA,SAAc8F,GAAd,IAAArN,EAAA/B,KAEMA,KAAKkC,OAAOsO,yBAETpB,EAAI3M,YAAezC,KAAKkD,KAAKJ,MAAK,SAAAF,GAAW,OAAAA,EAAQb,EAAKG,OAAOc,cAAgBoM,EAAIrN,EAAKG,OAAOc,iBAYpGhD,KAAKuQ,UAAUnB,GACfpP,KAAKyQ,mBAAmBrB,GACxBpP,KAAKoN,WAAWnH,KAAKmJ,KAGvBpP,KAAKsQ,OAAOlB,GACZpP,KAAKqP,kBAAkBD,GACvBpP,KAAKsE,SAAS2B,KACZjG,KAAKiN,YAAY5I,sBACfrE,KAAK0D,SACL0L,EACApP,KAAKkD,KACLlD,KAAKkC,UAIXlC,KAAK6P,SAAS3I,aACdlH,KAAK2I,YAAY1C,KAAKmJ,GACtBpP,KAAK6O,gBAQP9B,EAAAnN,UAAA6Q,mBAAA,SAAmBrB,EAAqBsB,EAAwBC,GAAhE,IAAA5O,EAAA/B,KAEE,QAFsC,IAAA0Q,IAAAA,GAAA,QAAwB,IAAAC,IAAAA,GAAA,GAC9DvB,EAAI3M,YAAa,GACZiO,GAAkBtB,EAAIpP,KAAKkC,OAAOQ,mBACrC,IAAK,IAAInD,EAAI,EAAG+C,EAAM8M,EAAIpP,KAAKkC,OAAOQ,mBAAmBhD,OAAQH,EAAI+C,IAAO/C,EAC1ES,KAAKuQ,UAAUnB,EAAIpP,KAAKkC,OAAOQ,mBAAmBnD,IAClDS,KAAKyQ,mBAAmBrB,EAAIpP,KAAKkC,OAAOQ,mBAAmBnD,GAAImR,GAGnE,GAAItB,EAAIpP,KAAKkC,OAAOqC,uBAAyBoM,EAAc,CACzD,IAAMnM,EAAYxE,KAAKiN,YAAYxJ,YACjCzD,KAAK0D,SACL0L,EAAIpP,KAAKkC,OAAOqC,qBAChBvE,KAAKkC,QAEHsC,GAAaA,EAAU/B,aACzBzC,KAAKuQ,UAAU/L,GACfxE,KAAKyQ,mBAAmBjM,GAAW,EAAMmM,GACzCnM,EAAUxE,KAAKkC,OAAOQ,mBAAmBU,KAAI,SAACR,GAExCA,EAAQb,EAAKG,OAAOc,aAAeoM,EAAIrN,EAAKG,OAAOc,cACrDjB,EAAKuO,OAAO1N,GACZb,EAAKsN,kBAAkBzM,GAAS,GAAO,QAK/C5C,KAAKwP,SACHxP,KAAKkD,OAST6J,EAAAnN,UAAAgR,gBAAA,SAAgBxB,GACdpP,KAAKoN,WAAWnH,KAAKmJ,GACrBpP,KAAKuQ,UAAUnB,GACfpP,KAAKyQ,mBAAmBrB,IAQ1BrC,EAAAnN,UAAAyP,kBAAA,SAAkBD,EAAqBsB,EAAwBC,GAA/D,IAAA5O,EAAA/B,KAIE,QAJqC,IAAA0Q,IAAAA,GAAA,QAAwB,IAAAC,IAAAA,GAAA,GACzD3Q,KAAKkC,OAAOC,uBACdiN,EAAI3M,YAAa,GAEf2M,EAAIpP,KAAKkC,OAAOQ,qBAAuBgO,EACzC,IAAK,IAAInR,EAAI,EAAG+C,EAAM8M,EAAIpP,KAAKkC,OAAOQ,mBAAmBhD,OAAQH,EAAI+C,IAAO/C,EACtES,KAAKkC,OAAO2O,oBAEd7Q,KAAKuQ,UAAUnB,EAAIpP,KAAKkC,OAAOQ,mBAAmBnD,IAElDS,KAAKqP,kBAAkBD,EAAIpP,KAAKkC,OAAOQ,mBAAmBnD,IAAI,GAAO,IAErES,KAAKsQ,OAAOlB,EAAIpP,KAAKkC,OAAOQ,mBAAmBnD,IAIrD,GAAI6P,EAAIpP,KAAKkC,OAAOqC,uBAAyBoM,EAAc,CACzD,IAAMG,EAAY9Q,KAAKiN,YAAYxJ,YACjCzD,KAAK0D,SACL0L,EAAIpP,KAAKkC,OAAOqC,qBAChBvE,KAAKkC,QAEP,IAAK4O,EACH,OAEF,IAAMrM,EAAoBqM,EAAU9Q,KAAKkC,OAAOQ,mBAAmBhD,OAC7DgF,EAAoB1E,KAAKkD,KAAKP,QAAO,SAACC,GAE1C,OAAOA,EAAQb,EAAKG,OAAOqC,sBAAwBuM,EAAU/O,EAAKG,OAAOc,eACxEtD,OAEC+E,EAAoB,GAAKC,EAAoB,IAC9C1E,KAAKkC,OAAO6O,sBACXrM,IAAsBoM,EAAU9Q,KAAKkC,OAAO6O,uBAC5CrM,IAAsBD,KAGxBzE,KAAKsQ,OAAOQ,GACZ9Q,KAAKqP,kBAAkByB,GAAW,GAAO,IAG7C9Q,KAAKwP,SACHxP,KAAKkD,OAIT6J,EAAAnN,UAAAoR,kBAAA,SAAkBzB,KAIlBxC,EAAAnN,UAAAwO,cAAA,SAAchH,GAAd,IAAArF,EAAA/B,KAEE,GADAoH,EAAOmD,2BAEJvK,KAAKiQ,gBAEJ7I,EAAOhH,MAAQyH,GACfT,EAAOhH,MAAQyH,GAIZ,GACL7H,KAAKiQ,gBACL7I,EAAOhH,MAAQyH,EAEf,OAAO7H,KAAK6O,oBALZ7O,KAAKiQ,gBAAiB,EAQxBrB,YAAW,WACL7M,EAAKkP,UACPlP,EAAKkP,SAASzG,YAAYpD,KAE3B,8CA3YmB8J,EAAAA,6BACD3N,KA5C0B8D,EAAAA,CAAhDG,EAAAA,UAAUc,EAAmB,CAAEb,QAAQ,oCAC/BJ,EAAAA,CAARC,EAAAA,sCACQD,EAAAA,CAARC,EAAAA,wCACQD,EAAAA,CAARC,EAAAA,wCACQD,EAAAA,CAARC,EAAAA,2CACQD,EAAAA,CAARC,EAAAA,gDACQD,EAAAA,CAARC,EAAAA,+CACQD,EAAAA,CAARC,EAAAA,wCACSD,EAAAA,CAATE,EAAAA,2CACSF,EAAAA,CAATE,EAAAA,yCACSF,EAAAA,CAATE,EAAAA,6CACSF,EAAAA,CAATE,EAAAA,4CAC+CF,EAAAA,CAA/CG,EAAAA,UAAU3C,EAAmB,CAAE4C,QAAQ,oCAqCxCJ,EAAAA,CADC8J,EAAAA,aAAa,QAAS,CAAC,yCAjDbpE,EAAyB9M,EAAA,CAVrCyH,EAAAA,UAAU,CACTC,SAAU,wBACVC,SAAA,k6DAEAwJ,UAAW,CACTC,IACAC,KAEFC,cAAeC,EAAAA,kBAAkBC,43CAEtB1E,eA6bGsE,IACd,MAAO,CACLK,QAASC,EAAAA,kBACTC,YAAaC,EAAAA,YAAW,WAAM,OAAA9E,KAC9B+E,OAAO,GAIX,SAAgBR,IACd,MAAO,CACLI,QAASK,EAAAA,cACTH,YAAaC,EAAAA,YAAW,WAAM,OAAA9E,KAC9B+E,OAAO,oBC3dT,SAAAE,IALShS,KAAAiS,SAAW,cAEVjS,KAAAkS,aAAe,IAAIjN,EAAAA,aAiB/B,OAZE+M,EAAApS,UAAA6F,SAAA,WACOzF,KAAKkN,kBACRlN,KAAKkN,gBAAkBlN,KAAKmS,wBAE9BnS,KAAKkJ,QAAU,CACbjB,KAAMjI,KAAK4C,QACXV,OAAQlC,KAAKkC,OACb+P,SAAUjS,KAAKiS,SACfC,aAAclS,KAAKkS,eAjBd7K,EAAAA,CAARC,EAAAA,sCACQD,EAAAA,CAARC,EAAAA,uCACQD,EAAAA,CAARC,EAAAA,wCACQD,EAAAA,CAARC,EAAAA,+CACSD,EAAAA,CAATE,EAAAA,6CACsDF,EAAAA,CAAtDG,EAAAA,UAAU,yBAA0B,CAAEC,QAAQ,kDANpCuK,EAAY/R,EAAA,CALxByH,EAAAA,UAAU,CACTC,SAAU,SACVC,SAAA,6hCAGWoK,mBCDX,SAAAI,EAAoBC,EAAwBC,GAAxBtS,KAAAqS,GAAAA,EAAwBrS,KAAAsS,MAAAA,EAFnCtS,KAAAuS,sBAAuB,EA6BlC,OAzBEH,EAAAxS,UAAA6F,SAAA,WACOzF,KAAKwS,uBACRtO,QAAQkM,KAAK,2EAIjBgC,EAAAxS,UAAAsG,YAAA,SAAYuM,GACLA,EAAcF,sBAGfE,EAAcF,qBAAqBlM,eAAiBoM,EAAcF,qBAAqBjE,eACzFtO,KAAK0S,4BAITN,EAAAxS,UAAA8S,yBAAA,WACM1S,KAAKuS,sBACPvS,KAAKqS,GAAGvL,cAAc6L,UAAUC,IAAI5S,KAAKwS,uBACzCxS,KAAKqS,GAAGvL,cAAc+L,gBAAe,IAErC7S,KAAKqS,GAAGvL,cAAc6L,UAAUG,OAAO9S,KAAKwS,uBAE9CxS,KAAKsS,MAAMS,yDAxBWC,EAAAA,kBAA2BC,EAAAA,qBAF1C5L,EAAAA,CAARC,EAAAA,oDACQD,EAAAA,CAARC,EAAAA,qDAFU8K,EAA4BnS,EAAA,CAHxCiT,EAAAA,UAAU,CACTvL,SAAU,6BAECyK,mBCyBb,SAAAe,KAAsC,OAAzBA,EAAsBlT,EAAA,CAlBlCmT,EAAAA,SAAS,CACRC,aAAc,CACZtG,EACAiF,EACAnN,EACAyD,EACA3G,EACAmG,EACAsK,GAEFkB,QAAS,CACPC,EAAAA,aACAC,EAAAA,YACAC,EAAAA,oBACAC,EAAAA,eAEFC,QAAS,CAAC5G,EAA2BqF,MAE1Be","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Pipe, PipeTransform } from '@angular/core';\n\nimport { AngularTagsInputConfig } from './tags-input-interfaces';\n\n@Pipe({\n  name: 'unAddedTags'\n})\nexport class UnAddedTagsPipe implements PipeTransform {\n  transform(tagsList: Array<any>, args: {tagsAdded: Array<any>, config: AngularTagsInputConfig}): any {\n    const result = [];\n    const {tagsAdded, config} = args;\n\n    // if the tagsList is falsy, return empty list\n    if (!tagsList) {\n      return [];\n    }\n\n    // if we have to show selected tags (adds selected: true to every item (or nested tag))\n    if (config.showTagsSelectedInDD) {\n      tagsList = this.setSelectedTags(tagsList, config, tagsAdded);\n    }\n\n    // if we don't have to hide tags, send the tagsList (final, processed) back\n    if (!config.hideAddedTags) {\n      return tagsList;\n    }\n\n    /**\n     * if we have to filter out the already selected tags in the dropdown, we'll filter these out\n     * and thus the already selected tags won't go back in the results for dropdown\n     */\n    for (let i = 0, len = tagsList.length; i < len; ++i) {\n      const currentTagItem = {...tagsList[i]};  // making sure we're not modifying the original object here\n      if (!this.isTagAlreadySelected(currentTagItem, tagsAdded, config)) { // if the tag to add isn't added already\n        currentTagItem.tiSelected = false;\n        if (config.nestedTagProperty && currentTagItem[config.nestedTagProperty]) {\n          currentTagItem[config.nestedTagProperty] = currentTagItem[config.nestedTagProperty].filter((tagItem) => {\n            return !this.isTagAlreadySelected(tagItem, tagsAdded, config);\n          });\n        }\n        result.push(currentTagItem);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Compares a tag against all the tags added based on config provided\n   * @param currentTag - the tag to check if it exists in the selection\n   * @param tagsAdded - an array of the tags added to the selection\n   * @param config - the config provided to the Angular Tags Input component\n   * @return boolean - if the tag is added already\n   */\n  isTagAlreadySelected(currentTag, tagsAdded, config: AngularTagsInputConfig) {\n    return tagsAdded.find(tagItem => {\n      let matchFound = false;\n      matchFound = this.areTagsMatching(currentTag, tagItem, config);\n      if (matchFound) {\n        return true;\n      } else if (tagItem[config.nestedTagProperty]) {\n        return this.isTagAlreadySelected(currentTag, tagItem[config.nestedTagProperty], config);\n      }\n      return false;\n    });\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Compares the two tags based on the identifier provided in the config\n   * @param currentTag - the tag in the iteration to compare\n   * @param tagItem - the tag (already selected) to compare with\n   * @param config - the config provided to the Angular Tags Input component\n   * @return boolean - if the tags passed are the same.\n   */\n  areTagsMatching(currentTag, tagItem, config) {\n    if (typeof tagItem[config.identifier] === 'number') {\n      // handling if the type of identifier is a number\n      return tagItem[config.identifier] === +currentTag[config.identifier];\n    } else if (typeof tagItem[config.identifier] === 'string' && typeof currentTag[config.identifier] === 'string') {\n      // handling if the type of identifier is a string\n      return tagItem[config.identifier].toLowerCase() === currentTag[config.identifier].toLowerCase();\n    }\n  }\n\n  setSelectedTags(tags, config: AngularTagsInputConfig, tagsAdded, isSelected = null) {\n    return tags.map(currentTag => {\n      currentTag.tiSelected = !!this.isTagAlreadySelected(currentTag, tagsAdded, config);\n      if (config.showTagsSelectedInDD && !!isSelected) {\n        currentTag.tiSelected = true;\n      }\n      if (currentTag[config.nestedTagProperty] && currentTag[config.nestedTagProperty].length) {\n        currentTag[config.nestedTagProperty] = this.setSelectedTags(\n          currentTag[config.nestedTagProperty],\n          config,\n          tagsAdded,\n          currentTag.tiSelected\n        );\n      }\n      return currentTag;\n    });\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { AngularTagsInputConfig } from './tags-input-interfaces';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AngularTagsInputService {\n  debugMode = false;\n  constructor() { }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Finds a tag by Id\n   * @param tagsData Array of the tags (could be heirarchical)\n   * @param tagId identifier of the tag to be found\n   * @param config the tags input config\n   * @returns the tag found, or `undefined`\n   */\n  findTagById(tagsData, tagId, config: AngularTagsInputConfig) {\n    for (let i = 0, len = tagsData.length; i < len; ++i) {\n      // tslint:disable-next-line:triple-equals\n      if (tagsData[i][config.identifier] == tagId) {\n        return tagsData[i];\n      }\n      if (tagsData[i][config.nestedTagProperty]) {\n        const nestedParentFound = this.findTagById(tagsData[i][config.nestedTagProperty], tagId, config);\n        if (nestedParentFound) {\n          return nestedParentFound;\n        }\n      }\n    }\n  }\n\n  setDebugMode(mode: boolean) {\n    this.debugMode = mode;\n  }\n\n  log(logMessage: any, logLabel = '') {\n    if (!this.debugMode) {\n      return;\n    }\n    console.log(logLabel, logMessage);\n  }\n\n  findParent(tagsArray, tagItem, config: AngularTagsInputConfig) {\n    for (let i = 0, len = tagsArray.length; i < len; ++i) {\n      // tslint:disable-next-line:triple-equals\n      if (tagsArray[i][config.identifier] == tagItem[config.identifier]) {\n        return tagsArray[i];\n      }\n      if (tagsArray[i][config.nestedTagProperty]) {\n        const nestedParentFound = this.findParent(tagsArray[i][config.nestedTagProperty], tagItem, config);\n        if (nestedParentFound) {\n          return nestedParentFound;\n        }\n      }\n    }\n  }\n\n  getMainTagAfterAdding(tagsArray, tagAdded, tags, config: AngularTagsInputConfig) {\n    if (tagAdded[config.nestedTagParentProp]) {\n      const parentTag = this.findTagById(\n        tagsArray,\n        tagAdded[config.nestedTagParentProp],\n        config\n      );\n      if (!parentTag) {\n        return;\n      }\n      const parentTagChildren = parentTag[config.nestedTagProperty].length;\n      const childrensSelected = parentTag[config.nestedTagProperty].filter((tagItem) => {\n        // tslint:disable-next-line:triple-equals\n        return !!tagItem.tiSelected;\n      }).length;\n      if (parentTagChildren > 0 && childrensSelected > 0 && childrensSelected === parentTagChildren) {\n        parentTag.tiSelected = true;\n        if (!parentTag[config.nestedTagParentProp]) {\n          return parentTag;\n        } else {\n          return this.getMainTagAfterAdding(tagsArray, parentTag, tags, config);\n        }\n      }\n    }\n    return tagAdded;\n  }\n}\n","import { Component, OnInit, Input, Output, EventEmitter, ViewChild, ElementRef, SimpleChanges, OnChanges } from '@angular/core';\nimport { AngularTagItem, AngularTagsInputConfig } from '../tags-input-interfaces';\nimport { FormGroup, FormControl } from '@angular/forms';\nimport { debounceTime, distinctUntilChanged } from 'rxjs/operators';\n\n@Component({\n  selector: 'ti-tag-input',\n  templateUrl: './tag-input.component.html',\n  styleUrls: ['./tag-input.component.scss']\n})\nexport class TagInputComponent implements OnInit, OnChanges {\n  @Input() inputClass = 'default';\n  @Input() config: AngularTagsInputConfig;\n  @Input() disabled = false;\n  @Output() valueChanged = new EventEmitter<string>();\n  @Output() inputFocused = new EventEmitter<string>();\n  @Output() inputBlurred = new EventEmitter<string>();\n  @Output() tagEntered = new EventEmitter<AngularTagItem>();\n  @ViewChild('inputEl', { static: true }) inputEl: ElementRef;\n  tagInputForm = new FormGroup({\n    tagInputVal: new FormControl('')\n  });\n  lastValueEmitted: string;\n  constructor() { }\n\n  ngOnInit() {\n    this.tagInputForm.get('tagInputVal')\n      .valueChanges\n      .pipe(\n        debounceTime(400),\n        distinctUntilChanged()\n      )\n      .subscribe((value) => {\n        this.lastValueEmitted = value;\n        this.valueChanged.emit(value);\n      });\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes.disabled !== undefined) {\n      if (changes.disabled.currentValue === true) {\n        this.tagInputForm.get('tagInputVal').disable();\n      } else {\n        this.tagInputForm.get('tagInputVal').enable();\n      }\n    }\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Emits the input focused event with the current search term value\n   */\n  emitInputFocused() {\n    if (this.disabled) {\n      return;\n    }\n    const searchTerm = this.tagInputForm.get('tagInputVal').value;\n    this.inputFocused.emit(searchTerm);\n\n    if (this.lastValueEmitted !== searchTerm) {\n      this.valueChanged.emit(searchTerm);\n      this.lastValueEmitted = searchTerm;\n    }\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc When the user presses enter key after entering the tag name\n   * @param inputEl - Reference to the input element so we can fetch the value\n   */\n  onEnterKeyPress() {\n    if (this.config.onlyFromAutoComplete) {\n      return;\n    }\n    const tagName = this.inputEl.nativeElement.value;\n    this.tagEntered.emit({\n      [this.config.displayProperty]: tagName,\n      [this.config.identifier]: tagName.toLowerCase(),\n      newTag: true\n    });\n    this.resetInput();\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Resets the input value\n   */\n  resetInput() {\n    this.inputEl.nativeElement.value = '';\n  }\n\n  emitInputBlurred($event) {\n    this.inputBlurred.emit($event);\n  }\n}\n","export const KEY_CODES = {\n  ARROW_DOWN: 'ArrowDown',\n  ARROW_UP: 'ArrowUp',\n  ENTER: 'Enter',\n  ESCAPE: 'Escape',\n  TAB: 'Tab'\n};\n","import { Pipe, PipeTransform } from '@angular/core';\nimport { AngularTagItem, AngularTagsInputConfig } from './tags-input-interfaces';\n\n@Pipe({\n  name: 'dropdownItemsFilter'\n})\nexport class DropdownItemsFilterPipe implements PipeTransform {\n\n  transform(tagItems: Array<AngularTagItem> = [], config: AngularTagsInputConfig, searchTerm = ''): any {\n    if (!searchTerm) {\n      return tagItems;\n    }\n    return [...tagItems]\n      .map((item: AngularTagItem) => this.getFilteredItem({...item}, config, searchTerm))\n      .filter(item => !!item);\n  }\n\n  getFilteredItem(item: AngularTagItem, config: AngularTagsInputConfig, searchTerm: string = '') {\n    if (searchTerm === '') {\n      return item;\n    }\n    let matches = false;\n    if (item[config.displayProperty].toLowerCase().includes(searchTerm.toLowerCase())) {\n      return item;\n    }\n\n    if (item[config.nestedTagProperty]) {\n      const childItems = item[config.nestedTagProperty].map(nestedItem => {\n        return this.getFilteredItem(nestedItem, config, searchTerm);\n      }).filter(nestedItem => !!nestedItem);\n\n      matches = childItems.length > 0;\n\n      if (matches) {\n        return {\n          ...item,\n          [config.nestedTagProperty]: [...childItems]\n        };\n      }\n    }\n\n    return null;\n  }\n\n}\n","import {\n  Component,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnInit,\n  Output,\n  SimpleChanges,\n  TemplateRef,\n  ViewChild\n} from '@angular/core';\nimport { ListKeyManager, ListKeyManagerOption } from '@angular/cdk/a11y';\nimport { UP_ARROW, DOWN_ARROW, ENTER } from '@angular/cdk/keycodes';\nimport {\n  AngularTagItem,\n  AngularTagsInputConfig,\n  AngularTagsInputDDFns\n} from '../tags-input-interfaces';\nimport { KEY_CODES } from '../constants';\nimport { AngularTagsInputService } from '../angular-tags-input.service';\nimport { DropdownItemsFilterPipe } from '../dropdown-items-filter.pipe';\n\n@Component({\n  selector: 'ti-dropdown',\n  templateUrl: './dropdown.component.html',\n  styleUrls: ['./dropdown.component.scss']\n})\nexport class DropdownComponent\n  implements OnInit, AngularTagsInputDDFns, OnChanges {\n  @Input() config: AngularTagsInputConfig;\n  @Input() listItems: Array<AngularTagItem> = [];\n  @Input() inputVal = '';\n  @Input() dropDownTemplate: TemplateRef<any>;\n  @Input() tagsLoading: boolean;\n  @Input() keyPress: any;\n  @Output() itemAdded = new EventEmitter<AngularTagItem>();\n  @Output() itemClicked = new EventEmitter<AngularTagItem>();\n  @ViewChild('defaultTagOptionTemplate', { static: true }) defaultTagOptionTemplate: TemplateRef<any>;\n  dropdownItemsFilter = new DropdownItemsFilterPipe();\n  ddIdPrefix: string;\n  context: any;\n  activeIndex: number;\n  identifierSeparator = '__';\n  keyboardEventsManager: ListKeyManager<ListKeyManagerOption>;\n  itemsMap: Map<string, any> = new Map<string, any>();\n  constructor(\n    private tagsInputService: AngularTagsInputService\n  ) {}\n\n  ngOnInit() {\n    if (!this.dropDownTemplate) {\n      // if there's no template provided, assign the default one\n      this.dropDownTemplate = this.defaultTagOptionTemplate;\n    }\n    this.context = {\n      items: [...this.listItems],\n      config: this.config,\n      tagsLoading: this.tagsLoading,\n      fns: {\n        onItemClicked: this.onItemClicked.bind(this)\n      }\n    };\n    this.keyboardEventsManager = new ListKeyManager([...this.listItems as any]);\n    this.populateItemsMap(this.listItems);\n    this.ddIdPrefix = this.getRandomString();\n    this.tagsInputService.log(this.itemsMap, 'items populated initially');\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    if (changes.listItems && !changes.listItems.firstChange) {\n      // if the list items change, update the context items (because they're not automatically updated)\n      this.filterItems(this.inputVal, changes.listItems.currentValue);\n      this.populateItemsMap(changes.listItems ? changes.listItems.currentValue : this.listItems);\n    }\n\n    if (\n      changes.inputVal && !changes.inputVal.firstChange\n    ) {\n      // if the list items change, update the context items (because they're not automatically updated)\n      this.filterItems(changes.inputVal.currentValue);\n      this.populateItemsMap(changes.listItems ? changes.listItems.currentValue : this.listItems);\n    }\n  }\n\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Updates the items property for the context provided to the dropdown template\n   * @param items - the list of items to be assigned\n   */\n\n  filterItems(searchTerm = this.inputVal, items = this.listItems) {\n    this.context.items = [...this.dropdownItemsFilter.transform(\n      items,\n      this.config,\n      searchTerm\n    )];\n    this.ddIdPrefix = this.getRandomString();\n  }\n\n  private getRandomString() {\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n  }\n\n  populateItemsMap(items, prefix = null) {\n    if (prefix === null) {\n      prefix = '';\n    } else {\n      prefix += this.identifierSeparator;\n    }\n    items.map((item, index) => {\n      const newPrefix = prefix + index;\n      item.tiIdentifier = newPrefix;\n      this.itemsMap[newPrefix] = item;\n      if (item[this.config.nestedTagProperty] && item[this.config.nestedTagProperty].length) {\n        this.populateItemsMap(item[this.config.nestedTagProperty], newPrefix);\n      }\n    });\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc When an option is clicked from the options dropdown\n   * @param item - item clicked\n   */\n  onItemClicked(item: AngularTagItem, $event = null) {\n    if ($event) {\n      $event.stopImmediatePropagation(); // for nested items\n    }\n    this.itemClicked.emit(item);\n  }\n\n  handleKeyUp(event: KeyboardEvent) {\n    event.stopImmediatePropagation();\n    if (!this.keyboardEventsManager) {\n      return;\n    }\n    const isKeyDown = this.isKeyDown(event);\n    const isKeyUp = this.isKeyUp(event);\n    const isKeyEnter = this.isKeyEnter(event);\n\n    if (isKeyDown || isKeyUp) {\n      // passing the event to key manager so we get a change fired\n      this.setActiveElement(event);\n    } else if (\n      isKeyEnter &&\n      this.keyboardEventsManager.activeItem\n    ) {\n      this.itemClicked.emit(\n        this.keyboardEventsManager.activeItem as AngularTagItem\n      );\n    }\n  }\n\n  isKeyDown(event) {\n    // tslint:disable-next-line: deprecation\n    return event.key === KEY_CODES.ARROW_DOWN || event.keyCode === DOWN_ARROW;\n  }\n\n  isKeyUp(event) {\n    // tslint:disable-next-line: deprecation\n    return event.key === KEY_CODES.ARROW_UP || event.keyCode === UP_ARROW;\n  }\n\n  isKeyEnter(event) {\n    // tslint:disable-next-line: deprecation\n    return event.key === KEY_CODES.ENTER || event.keyCode === ENTER;\n  }\n\n  setActiveElement(event) {\n    const isKeyDown = this.isKeyDown(event);\n    const isKeyUp = this.isKeyUp(event);\n    const previousActiveItem = { ...this.keyboardEventsManager.activeItem } as AngularTagItem;\n    if (isKeyDown) {\n      this.setNextActiveElement(previousActiveItem, this.listItems);\n    } else if (isKeyUp) {\n      this.setPreviousActiveElement(previousActiveItem, this.listItems);\n    }\n  }\n\n  setNextActiveElement(currentActiveItem: AngularTagItem, items) {\n    const identifier = currentActiveItem.tiIdentifier;\n    if (!identifier) {\n      items[0].tiKeyboardActive = true;\n      this.keyboardEventsManager.setFirstItemActive();\n      return;\n    }\n    const keyIdentifierArr = identifier.split(this.identifierSeparator);\n    let keyIdentifier;\n    let treeItems;\n    let index;\n    keyIdentifier = keyIdentifierArr.length > 1 ?\n      [...keyIdentifierArr].splice(0, keyIdentifierArr.length - 1).join(this.identifierSeparator) :\n      keyIdentifierArr[0];\n    treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}${this.identifierSeparator}`).test(key));\n    if (!treeItems.length) {\n      treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}$`).test(key));\n    }\n    index = treeItems.findIndex(id => id === identifier);\n    if (index === treeItems.length - 1) {\n      this.setActiveElementRecursively(this.findNextParent(keyIdentifierArr), this.listItems);\n    } else  {\n      this.setActiveElementRecursively(treeItems[index + 1], this.listItems);\n    }\n  }\n\n  findNextParent(keyIdentifierArr) {\n    let keyIdentifier;\n    let treeItems;\n    if (keyIdentifierArr.length === 1) {\n      const nextIdentifier = `${+keyIdentifierArr[0] + 1}`;\n      if (this.itemsMap[nextIdentifier]) {\n        return nextIdentifier;\n      }\n      return keyIdentifierArr[0];\n    }\n    const nextIdArr = [...keyIdentifierArr].splice(0, keyIdentifierArr.length - 1);\n    nextIdArr[nextIdArr.length - 1] = `${(+nextIdArr[nextIdArr.length - 1]) + 1}`;\n    keyIdentifier = nextIdArr.join(this.identifierSeparator);\n    treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}`).test(key));\n    if (treeItems.length) {\n      return treeItems[0];\n    } else {\n      return this.findNextParent([...keyIdentifierArr.splice(0, keyIdentifierArr.length - 1)]);\n    }\n  }\n\n  setPreviousActiveElement(currentActiveItem: AngularTagItem, items) {\n    const identifier = currentActiveItem.tiIdentifier;\n    if (!identifier) {\n      items[items.length - 1].tiKeyboardActive = true;\n      this.keyboardEventsManager.setActiveItem(items[items.length - 1]);\n      return;\n    }\n\n    const keyIdentifierArr = identifier.split(this.identifierSeparator);\n    let keyIdentifier;\n    let treeItems;\n    let index;\n    keyIdentifier = keyIdentifierArr.length > 1 ?\n      [...keyIdentifierArr].splice(0, keyIdentifierArr.length - 1).join(this.identifierSeparator) :\n      keyIdentifierArr[0];\n    treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}(${this.identifierSeparator})?`).test(key));\n    if (!treeItems.length) {\n      treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}$`).test(key));\n    }\n    index = treeItems.findIndex(id => id === identifier);\n    if (treeItems.length === 1 || index === 0) {\n      this.setActiveElementRecursively(this.findPrevousParentLastChild(keyIdentifierArr, identifier), this.listItems);\n    } else {\n      this.setActiveElementRecursively(treeItems[index - 1], this.listItems);\n    }\n  }\n\n  findPrevousParentLastChild(keyIdentifierArr, prevItemIdentifier: string) {\n    let keyIdentifier;\n    const isOnlyItem = keyIdentifierArr.length === 1;\n    const prevIdArr = !!isOnlyItem ?\n      [...keyIdentifierArr] :\n      [...keyIdentifierArr].splice(0, keyIdentifierArr.length - 1);\n    prevIdArr[prevIdArr.length - 1] = !!isOnlyItem ? `${(+prevIdArr[prevIdArr.length - 1]) - 1}` : prevIdArr[prevIdArr.length - 1];\n    keyIdentifier = prevIdArr.join(this.identifierSeparator);\n    let treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}${this.identifierSeparator}`).test(key));\n    if (!treeItems.length) {\n      treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}$`).test(key));\n    }\n    if (treeItems.length) {\n      if (treeItems.indexOf(prevItemIdentifier) !== -1) {\n        return keyIdentifier;\n      }\n      return treeItems[treeItems.length - 1];\n    } else if (keyIdentifierArr.length > 1) {\n      return this.findPrevousParentLastChild([...keyIdentifierArr.splice(0, keyIdentifierArr.length - 1)], prevItemIdentifier);\n    } else {\n      keyIdentifier = keyIdentifierArr.join(this.identifierSeparator);\n      return keyIdentifier;\n    }\n  }\n\n  setActiveElementRecursively(identifier, items) {\n    for (let i = 0, len = items.length; i < len; ++i ) {\n      items[i].tiKeyboardActive = false;\n      if (items[i].tiIdentifier === identifier) {\n        this.keyboardEventsManager = new ListKeyManager([...items as any]);\n        items[i].tiKeyboardActive = true; // select next item\n        this.keyboardEventsManager.setActiveItem(items[i] as any);\n      }\n      if (items[i][this.config.nestedTagProperty] && items[i][this.config.nestedTagProperty].length) {\n        this.setActiveElementRecursively(identifier, items[i][this.config.nestedTagProperty]);\n      }\n    }\n  }\n}\n","import { ScrollStrategy, ScrollStrategyOptions } from '@angular/cdk/overlay';\nimport {\n  AfterViewInit,\n  Component,\n  EventEmitter,\n  forwardRef,\n  Input,\n  OnChanges,\n  OnInit,\n  Output,\n  SimpleChanges,\n  TemplateRef,\n  ViewChild,\n  ViewEncapsulation,\n  HostListener,\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR, NG_VALIDATORS, Validator, FormControl } from '@angular/forms';\n\nimport { AngularTagsInputService } from './angular-tags-input.service';\nimport { TagInputComponent } from './tag-input/tag-input.component';\nimport { AngularTagItem, AngularTagsInputConfig } from './tags-input-interfaces';\nimport { UnAddedTagsPipe } from './un-added-tags.pipe';\nimport { DropdownComponent } from './dropdown/dropdown.component';\nimport { KEY_CODES } from './constants';\n\n@Component({\n  selector: 'ti-angular-tags-input',\n  templateUrl: './angular-tags-input.component.html',\n  styleUrls: ['./angular-tags-input.component.scss'],\n  providers: [\n    getAngularTagsInputValueAccessor(),\n    getAngularTagsInputValidatorsProvider()\n  ],\n  encapsulation: ViewEncapsulation.None\n})\nexport class AngularTagsInputComponent implements OnInit, AfterViewInit, ControlValueAccessor, OnChanges, Validator {\n  @ViewChild(DropdownComponent, { static: false }) dropdown: DropdownComponent;\n  @Input() config: AngularTagsInputConfig;\n  @Input() tagsData: Array<any> = [];\n  @Input() disabled = false;\n  @Input() tagsLoading: boolean;\n  @Input() dropDownTemplate: TemplateRef<any> = null;\n  @Input() tagItemTemplate: TemplateRef<any> = null;\n  @Input() required = false;\n  @Output() tagRemoved = new EventEmitter();\n  @Output() tagAdded = new EventEmitter();\n  @Output() valueChanged = new EventEmitter();\n  @Output() itemClicked = new EventEmitter();\n  @ViewChild(TagInputComponent, { static: true }) tagInput: TagInputComponent;\n  tags: Array<AngularTagItem> = [];\n  isInputFocused: boolean;\n  inputVal: string;\n  defaultConfig: AngularTagsInputConfig = {\n    defaultClass: 'angular-tags-input',\n    additionalClasses: '',\n    displayProperty: 'value',\n    identifier: 'id',\n    onlyFromAutoComplete: false,\n    placeholder: 'Search',\n    hideAddedTags: true,\n    nestedTagProperty: '',\n    showTagsSelectedInDD: false,\n    hideTags: false,\n    maxItems: null,\n    nestedTagParentProp: '',\n    keyboardActiveClass: 'angular-tags-dropdown__list__item--active'\n  };\n  onChange: (items: AngularTagItem[]) => void;\n  dropdownOverlayPosition = [\n    { offsetY: 12, originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\n    { offsetY: -28, originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom' },\n    { offsetY: 28, originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'bottom' },\n    { offsetY: -28, originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom' },\n  ];\n  ddScrollStrategy: ScrollStrategy;\n  isDropdownOpen: boolean;\n  dropdownShownYet: boolean;\n  unAddedTagsPipe = new UnAddedTagsPipe();\n  constructor(\n    private readonly sso: ScrollStrategyOptions,\n    private tagsService: AngularTagsInputService\n  ) { }\n\n\n  @HostListener('keyup', ['$event'])\n  keyEvent(event) {\n    this.inputKeyPress(event);\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    // if there's no change in the tagsData, do nothing\n    if (!changes.tagsData || !this.isInputFocused) {\n      return;\n    }\n\n    // If the previous walue was `null` or `undefined`, we're initializing that as an array here\n    // so we can avoid breaking the process further.\n    if (!changes.tagsData.previousValue) {\n      changes.tagsData.previousValue = [];\n    }\n    // if we have the value of the tags changed, we need to show the dropdown immediately\n    // we don't show this on the first change, because that's when the first value is assigned\n    if (\n      changes.tagsData && changes.tagsData.currentValue !== changes.tagsData.previousValue\n      && !changes.tagsData.firstChange\n    ) {\n      // if the values don't match, show the dropdown\n      if (changes.tagsData.currentValue.length !== changes.tagsData.previousValue.length && !!this.dropdownShownYet) {\n        return this.showDropdown(changes.tagsData.currentValue);\n      }\n\n      if (changes.tagsData.previousValue.length === 0) {\n        return;\n      }\n\n      /* since the values are array, we need to compare the elements within\n       * avoiding the usage of any external library, matching the elements using identifier\n       * of the elements here\n       */\n      for (let i = 0, len = changes.tagsData.currentValue.length; i < len; ++i) {\n        if (changes.tagsData.currentValue[i][this.config.identifier] !== changes.tagsData.previousValue[i][this.config.identifier]) {\n          // as soon as the difference in elements is found, show the element and stop further execution of for loop\n          return this.showDropdown(changes.tagsData.currentValue);\n        }\n      }\n    }\n  }\n\n  onFocusChange(val: boolean) {\n    this.isInputFocused = val;\n    if (!val && this.config.hideDDOnBlur) {\n      setTimeout(() => {\n        this.hideDropdown();\n      }, 400);\n    }\n  }\n\n  onInputValueChanged(val: string) {\n    this.inputVal = val;\n    this.valueChanged.emit(val);\n  }\n\n  ngOnInit() {\n    this.config = { // applying the configuration provided\n      ...this.defaultConfig,\n      ...this.config\n    };\n    this.ddScrollStrategy = this.sso.reposition();\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Triggers when the value of the form control (or ngModel) is changed.\n   * We're using the handler to assign the values to the tags array that we have.\n   */\n  writeValue(tags: Array<any>): void {\n    tags = tags ? tags : [];\n    tags = Array.isArray(tags) ? tags : [tags];\n    this.tags = tags.map((tag) => {\n      return {\n        ...tag,\n        ...{\n          [this.config.identifier]: tag[this.config.identifier],\n          [this.config.displayProperty]: tag[this.config.displayProperty],\n        }\n      };\n    });\n\n    if (this.config.showTagsSelectedInDD) {\n      setTimeout(() => {\n        this.tags.map((tag) => {\n          this.selectRelatedTags(tag);\n        });\n      });\n    }\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Registers the on change function to the value accessor\n   */\n  registerOnChange( fn: any ): void {\n    this.onChange = fn;\n  }\n\n  /**\n   * Validator function for the form control\n   * Doesn't do anything if the control is not required\n   * If it is required, checks if the control contains value\n   */\n  validate(control: FormControl) {\n    if (this.required === false) {\n      return null;\n    }\n    return (!!control.value && control.value.length) ? null : {\n      required: true,\n    };\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Triggers when the tag input is focused\n   */\n  onInputFocus() {\n    if (this.config.clearInputOnFocus) {\n      if (this.tagInput.lastValueEmitted !== '') {\n        this.tagInput.tagInputForm.get('tagInputVal').setValue('');\n      }\n      this.tagInput.resetInput();\n    }\n    if (this.config.clearTagsOnFocus) {\n      this.tags.length = 0;\n    }\n    this.showDropdown();\n    this.onFocusChange(true);\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Shows the dropdown with options listing\n   */\n  showDropdown(recentTags: Array<any> = null) {\n    const unAddedTags = this.unAddedTagsPipe.transform(\n      !!recentTags ? recentTags : this.tagsData,\n      {\n        tagsAdded: this.tags,\n        config: this.config\n      }\n    );\n    if (unAddedTags.length) { // only show dropdown when we have data to show\n      this.isDropdownOpen = true;\n    }\n    if (!this.dropdownShownYet) {\n      this.dropdownShownYet = true;\n    }\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Hides the options listing dropdown\n   */\n  hideDropdown() {\n    this.isDropdownOpen = false;\n    this.tagsData = this.removeKeyboardSelection(this.tagsData);\n  }\n\n  removeKeyboardSelection(items: Array<AngularTagItem>) {\n    return items.map((tag: AngularTagItem) => {\n      if (tag[this.config.nestedTagProperty] && tag[this.config.nestedTagProperty].length) {\n        tag[this.config.nestedTagProperty] = this.removeKeyboardSelection(tag[this.config.nestedTagProperty]);\n      }\n      return {\n        ...tag,\n        tiKeyboardActive: false\n      };\n    });\n  }\n\n  ngAfterViewInit() {\n    if (!!this.config || !this.onChange) {\n      console.warn('Please use ngModel or FormControlName with <ti-angular-tags-input>');\n    }\n    if (this.config.nestedTagProperty) {\n      // we need the parent property to be able to unselect the parent when a child tag is unselected\n      if (!this.config.nestedTagParentProp) {\n        // tslint:disable-next-line:max-line-length\n        throw new Error('nestedTagProperty provided but nestedTagParentProp not provided.\\nThis will cause the parent tag to not remove if any of the children is removed');\n      }\n    }\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Adds the tag in the tags list (tags array).\n   * Avoids duplicate tags addition\n   * @param tag - tag to add\n   */\n  addTag(tag: AngularTagItem) {\n    if (this.config.showTagsSelectedInDD) {\n      tag.tiSelected = true; // marks the element as selected\n    }\n    if (this.config.maxItems > 0 && this.tags.length === this.config.maxItems) {\n      return;\n    }\n    if (!this.tags.find(tagItem => tagItem[this.config.identifier] === tag[this.config.identifier])) {\n      this.tags = [...this.tags, tag];\n      this.onChange(\n        this.tags\n      );\n    }\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Removes the tags from the tags list\n   * @param tag - tag to remove\n   */\n  removeTag(tag: AngularTagItem) {\n    this.tags = this.tags.filter((tagItem) => tagItem[this.config.identifier] !== tag[this.config.identifier]);\n    // when we've removed all the tags, we want to get the default tags\n    if (this.tags.length === 0) {\n      this.tagInput.resetInput();\n      this.valueChanged.emit('');\n    }\n    this.onChange(\n      this.tags\n    );\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Triggers when the item is clicked from the dropdown\n   * @param tag - tag selected\n   */\n  onItemClicked(tag: AngularTagItem) {\n    // if we don't have to toggle, add the item as tag right away\n    if (this.config.toggleSelectionOnClick) {\n      // we have to toggle selection. First, let's see if the tag doesn't exist already in the selected tags\n      if (!tag.tiSelected && !this.tags.find(tagItem => tagItem[this.config.identifier] === tag[this.config.identifier])) {\n        this.addTag(tag);\n        this.selectRelatedTags(tag);\n        this.tagAdded.emit(\n          this.tagsService.getMainTagAfterAdding(\n            this.tagsData,\n            tag,\n            this.tags,\n            this.config\n          )\n        );\n      } else {  // if the tag is already selected, remove\n        this.removeTag(tag);\n        this.removeTagSelection(tag);\n        this.tagRemoved.emit(tag);\n      }\n    } else {\n      this.addTag(tag);\n      this.selectRelatedTags(tag);\n      this.tagAdded.emit(\n        this.tagsService.getMainTagAfterAdding(\n          this.tagsData,\n          tag,\n          this.tags,\n          this.config\n        )\n      );\n    }\n    this.tagInput.resetInput();\n    this.itemClicked.emit(tag);\n    this.hideDropdown();\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Removes the tag seleced state (and of the children)\n   * @param tag - the tag to unmark as selected\n   */\n  removeTagSelection(tag: AngularTagItem, ignoreChildren = false, ignoreParent = false) {\n    tag.tiSelected = false;\n    if (!ignoreChildren && tag[this.config.nestedTagProperty]) {\n      for (let i = 0, len = tag[this.config.nestedTagProperty].length; i < len; ++i) {\n        this.removeTag(tag[this.config.nestedTagProperty][i]);\n        this.removeTagSelection(tag[this.config.nestedTagProperty][i], ignoreChildren);\n      }\n    }\n    if (tag[this.config.nestedTagParentProp] && !ignoreParent) {\n      const parentTag = this.tagsService.findTagById(\n        this.tagsData,\n        tag[this.config.nestedTagParentProp],\n        this.config\n      );\n      if (parentTag && parentTag.tiSelected) {\n        this.removeTag(parentTag);\n        this.removeTagSelection(parentTag, true, ignoreParent);\n        parentTag[this.config.nestedTagProperty].map((tagItem) => {\n          // tslint:disable-next-line:triple-equals\n          if (tagItem[this.config.identifier] != tag[this.config.identifier]) {\n            this.addTag(tagItem);\n            this.selectRelatedTags(tagItem, false, true);\n          }\n        });\n      }\n    }\n    this.onChange(\n      this.tags\n    );\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc triggers on close button click of the tags\n   * @param tag - the tag to remove\n   */\n  tagCloseClicked(tag) {\n    this.tagRemoved.emit(tag);\n    this.removeTag(tag);\n    this.removeTagSelection(tag);\n  }\n\n  /**\n   * @author Ahsan Ayaz\n   * @desc Selects/adds the retated tags (parent and/or children)\n   * @param tag - the tag to mark as selected\n   */\n  selectRelatedTags(tag: AngularTagItem, ignoreChildren = false, ignoreParent = false) {\n    if (this.config.showTagsSelectedInDD) {\n      tag.tiSelected = true;\n    }\n    if (tag[this.config.nestedTagProperty] && !ignoreChildren) {\n      for (let i = 0, len = tag[this.config.nestedTagProperty].length; i < len; ++i) {\n        if (this.config.showParentTagsOnly) {\n          // remove the children if we only have to keep parent\n          this.removeTag(tag[this.config.nestedTagProperty][i]);\n          // making sure we're targeting only children, ignoring parents\n          this.selectRelatedTags(tag[this.config.nestedTagProperty][i], false, true);\n        } else {\n          this.addTag(tag[this.config.nestedTagProperty][i]);\n        }\n      }\n    }\n    if (tag[this.config.nestedTagParentProp] && !ignoreParent) {\n      const parentTag = this.tagsService.findTagById(\n        this.tagsData,\n        tag[this.config.nestedTagParentProp],\n        this.config\n      );\n      if (!parentTag) {\n        return;\n      }\n      const parentTagChildren = parentTag[this.config.nestedTagProperty].length;\n      const childrensSelected = this.tags.filter((tagItem) => {\n        // tslint:disable-next-line:triple-equals\n        return tagItem[this.config.nestedTagParentProp] == parentTag[this.config.identifier];\n      }).length;\n      if (\n        ( parentTagChildren > 0 && childrensSelected > 0 ) &&\n        (this.config.childrenCountProperty ?\n          childrensSelected === parentTag[this.config.childrenCountProperty] :\n          childrensSelected === parentTagChildren\n        )\n      ) {\n        this.addTag(parentTag);\n        this.selectRelatedTags(parentTag, false, false);\n      }\n    }\n    this.onChange(\n      this.tags\n    );\n  }\n\n  registerOnTouched(fn: any): void {\n    // throw new Error(\"Method not implemented.\");\n  }\n\n  inputKeyPress($event) {\n    $event.stopImmediatePropagation();\n    if (\n      !this.isDropdownOpen &&\n      (\n        $event.key === KEY_CODES.ARROW_UP ||\n        $event.key === KEY_CODES.ARROW_DOWN\n      )\n    ) {\n      this.isDropdownOpen = true;\n    } else if (\n      this.isDropdownOpen &&\n      $event.key === KEY_CODES.ESCAPE\n    ) {\n      return this.hideDropdown();\n    }\n    // so we have the dropdown shown\n    setTimeout(() => {\n      if (this.dropdown) {\n        this.dropdown.handleKeyUp($event);\n      }\n    }, 10);\n  }\n\n}\n\n\nexport function getAngularTagsInputValueAccessor() {\n  return {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => AngularTagsInputComponent),\n    multi: true,\n  };\n}\n\nexport function getAngularTagsInputValidatorsProvider() {\n  return {\n    provide: NG_VALIDATORS,\n    useExisting: forwardRef(() => AngularTagsInputComponent),\n    multi: true,\n  };\n}\n","import { Component, EventEmitter, Input, OnInit, Output, TemplateRef, ViewChild } from '@angular/core';\n\nimport { AngularTagItem, AngularTagsInputConfig } from '../tags-input-interfaces';\n\n@Component({\n  selector: 'ti-tag',\n  templateUrl: './tag.component.html',\n  styleUrls: ['./tag.component.scss']\n})\nexport class TagComponent implements OnInit {\n  @Input() config: AngularTagsInputConfig;\n  @Input() tagItem: AngularTagItem;\n  @Input() tagClass = 'default-tag';\n  @Input() tagItemTemplate: TemplateRef<any>;\n  @Output() closeClicked = new EventEmitter<AngularTagItem>();\n  @ViewChild('defaultTagItemTemplate', { static: true }) defaultTagItemTemplate: TemplateRef<any>;\n  context: any;\n  constructor() { }\n\n  ngOnInit() {\n    if (!this.tagItemTemplate) { // if there's no template provided, assign the default one\n      this.tagItemTemplate = this.defaultTagItemTemplate;\n    }\n    this.context = {\n      item: this.tagItem,\n      config: this.config,\n      tagClass: this.tagClass,\n      closeClicked: this.closeClicked\n    };\n  }\n\n}\n","import { Directive, Input, OnChanges, SimpleChanges, ElementRef, ChangeDetectorRef, OnInit } from '@angular/core';\n\n@Directive({\n  selector: '[tiKeyboardActiveClass]'\n})\nexport class KeyboardActiveClassDirective implements OnInit, OnChanges {\n  @Input() isKeyboardActiveItem = false;\n  @Input() tiKeyboardActiveClass: string;\n  constructor(private el: ElementRef, private cdRef: ChangeDetectorRef) { }\n\n  ngOnInit() {\n    if (!this.tiKeyboardActiveClass) {\n      console.warn('tiKeyboardActiveClass needs a class to apply. But no class was passed.');\n    }\n  }\n\n  ngOnChanges(simpleChanges: SimpleChanges) {\n    if (!simpleChanges.isKeyboardActiveItem) {\n      return;\n    }\n    if (simpleChanges.isKeyboardActiveItem.currentValue !== simpleChanges.isKeyboardActiveItem.previousValue) {\n      this.evaluateClassApplication();\n    }\n  }\n\n  evaluateClassApplication() {\n    if (this.isKeyboardActiveItem) {\n      this.el.nativeElement.classList.add(this.tiKeyboardActiveClass);\n      this.el.nativeElement.scrollIntoView(false);\n    } else {\n      this.el.nativeElement.classList.remove(this.tiKeyboardActiveClass);\n    }\n    this.cdRef.markForCheck();\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { AngularTagsInputComponent } from './angular-tags-input.component';\nimport { TagComponent } from './tag/tag.component';\nimport { TagInputComponent } from './tag-input/tag-input.component';\nimport { DropdownComponent } from './dropdown/dropdown.component';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { OverlayModule } from '@angular/cdk/overlay';\nimport { UnAddedTagsPipe } from './un-added-tags.pipe';\nimport { DropdownItemsFilterPipe } from './dropdown-items-filter.pipe';\nimport { KeyboardActiveClassDirective } from './keyboard-active-class/keyboard-active-class.directive';\n\n@NgModule({\n  declarations: [\n    AngularTagsInputComponent,\n    TagComponent,\n    TagInputComponent,\n    DropdownComponent,\n    UnAddedTagsPipe,\n    DropdownItemsFilterPipe,\n    KeyboardActiveClassDirective\n  ],\n  imports: [\n    CommonModule,\n    FormsModule,\n    ReactiveFormsModule,\n    OverlayModule\n  ],\n  exports: [AngularTagsInputComponent, KeyboardActiveClassDirective]\n})\nexport class AngularTagsInputModule { }\n"]}