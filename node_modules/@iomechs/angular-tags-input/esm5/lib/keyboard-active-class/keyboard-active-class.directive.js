import * as tslib_1 from "tslib";
import { Directive, Input, OnChanges, SimpleChanges, ElementRef, ChangeDetectorRef, OnInit } from '@angular/core';
var KeyboardActiveClassDirective = /** @class */ (function () {
    function KeyboardActiveClassDirective(el, cdRef) {
        this.el = el;
        this.cdRef = cdRef;
        this.isKeyboardActiveItem = false;
    }
    KeyboardActiveClassDirective.prototype.ngOnInit = function () {
        if (!this.tiKeyboardActiveClass) {
            console.warn('tiKeyboardActiveClass needs a class to apply. But no class was passed.');
        }
    };
    KeyboardActiveClassDirective.prototype.ngOnChanges = function (simpleChanges) {
        if (!simpleChanges.isKeyboardActiveItem) {
            return;
        }
        if (simpleChanges.isKeyboardActiveItem.currentValue !== simpleChanges.isKeyboardActiveItem.previousValue) {
            this.evaluateClassApplication();
        }
    };
    KeyboardActiveClassDirective.prototype.evaluateClassApplication = function () {
        if (this.isKeyboardActiveItem) {
            this.el.nativeElement.classList.add(this.tiKeyboardActiveClass);
            this.el.nativeElement.scrollIntoView(false);
        }
        else {
            this.el.nativeElement.classList.remove(this.tiKeyboardActiveClass);
        }
        this.cdRef.markForCheck();
    };
    KeyboardActiveClassDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    tslib_1.__decorate([
        Input()
    ], KeyboardActiveClassDirective.prototype, "isKeyboardActiveItem", void 0);
    tslib_1.__decorate([
        Input()
    ], KeyboardActiveClassDirective.prototype, "tiKeyboardActiveClass", void 0);
    KeyboardActiveClassDirective = tslib_1.__decorate([
        Directive({
            selector: '[tiKeyboardActiveClass]'
        })
    ], KeyboardActiveClassDirective);
    return KeyboardActiveClassDirective;
}());
export { KeyboardActiveClassDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Ym9hcmQtYWN0aXZlLWNsYXNzLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bpb21lY2hzL2FuZ3VsYXItdGFncy1pbnB1dC8iLCJzb3VyY2VzIjpbImxpYi9rZXlib2FyZC1hY3RpdmUtY2xhc3Mva2V5Ym9hcmQtYWN0aXZlLWNsYXNzLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLGFBQWEsRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBS2xIO0lBR0Usc0NBQW9CLEVBQWMsRUFBVSxLQUF3QjtRQUFoRCxPQUFFLEdBQUYsRUFBRSxDQUFZO1FBQVUsVUFBSyxHQUFMLEtBQUssQ0FBbUI7UUFGM0QseUJBQW9CLEdBQUcsS0FBSyxDQUFDO0lBRWtDLENBQUM7SUFFekUsK0NBQVEsR0FBUjtRQUNFLElBQUksQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDL0IsT0FBTyxDQUFDLElBQUksQ0FBQyx3RUFBd0UsQ0FBQyxDQUFDO1NBQ3hGO0lBQ0gsQ0FBQztJQUVELGtEQUFXLEdBQVgsVUFBWSxhQUE0QjtRQUN0QyxJQUFJLENBQUMsYUFBYSxDQUFDLG9CQUFvQixFQUFFO1lBQ3ZDLE9BQU87U0FDUjtRQUNELElBQUksYUFBYSxDQUFDLG9CQUFvQixDQUFDLFlBQVksS0FBSyxhQUFhLENBQUMsb0JBQW9CLENBQUMsYUFBYSxFQUFFO1lBQ3hHLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO1NBQ2pDO0lBQ0gsQ0FBQztJQUVELCtEQUF3QixHQUF4QjtRQUNFLElBQUksSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQzdCLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzdDO2FBQU07WUFDTCxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1NBQ3BFO1FBQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUM1QixDQUFDOztnQkF6QnVCLFVBQVU7Z0JBQWlCLGlCQUFpQjs7SUFGM0Q7UUFBUixLQUFLLEVBQUU7OEVBQThCO0lBQzdCO1FBQVIsS0FBSyxFQUFFOytFQUErQjtJQUY1Qiw0QkFBNEI7UUFIeEMsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLHlCQUF5QjtTQUNwQyxDQUFDO09BQ1csNEJBQTRCLENBOEJ4QztJQUFELG1DQUFDO0NBQUEsQUE5QkQsSUE4QkM7U0E5QlksNEJBQTRCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBFbGVtZW50UmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t0aUtleWJvYXJkQWN0aXZlQ2xhc3NdJ1xufSlcbmV4cG9ydCBjbGFzcyBLZXlib2FyZEFjdGl2ZUNsYXNzRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBpc0tleWJvYXJkQWN0aXZlSXRlbSA9IGZhbHNlO1xuICBASW5wdXQoKSB0aUtleWJvYXJkQWN0aXZlQ2xhc3M6IHN0cmluZztcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZiwgcHJpdmF0ZSBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHsgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICghdGhpcy50aUtleWJvYXJkQWN0aXZlQ2xhc3MpIHtcbiAgICAgIGNvbnNvbGUud2FybigndGlLZXlib2FyZEFjdGl2ZUNsYXNzIG5lZWRzIGEgY2xhc3MgdG8gYXBwbHkuIEJ1dCBubyBjbGFzcyB3YXMgcGFzc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKHNpbXBsZUNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoIXNpbXBsZUNoYW5nZXMuaXNLZXlib2FyZEFjdGl2ZUl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNpbXBsZUNoYW5nZXMuaXNLZXlib2FyZEFjdGl2ZUl0ZW0uY3VycmVudFZhbHVlICE9PSBzaW1wbGVDaGFuZ2VzLmlzS2V5Ym9hcmRBY3RpdmVJdGVtLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgIHRoaXMuZXZhbHVhdGVDbGFzc0FwcGxpY2F0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVDbGFzc0FwcGxpY2F0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzS2V5Ym9hcmRBY3RpdmVJdGVtKSB7XG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLnRpS2V5Ym9hcmRBY3RpdmVDbGFzcyk7XG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLnRpS2V5Ym9hcmRBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIHRoaXMuY2RSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxufVxuIl19