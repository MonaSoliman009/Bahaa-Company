import { __decorate } from 'tslib';
import { Pipe, ɵɵdefineInjectable, Injectable, EventEmitter, Input, Output, ViewChild, Component, HostListener, forwardRef, ViewEncapsulation, ElementRef, ChangeDetectorRef, Directive, NgModule } from '@angular/core';
import { ScrollStrategyOptions, OverlayModule } from '@angular/cdk/overlay';
import { FormGroup, FormControl, NG_VALUE_ACCESSOR, NG_VALIDATORS, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { ListKeyManager } from '@angular/cdk/a11y';
import { DOWN_ARROW, UP_ARROW, ENTER } from '@angular/cdk/keycodes';
import { CommonModule } from '@angular/common';

let UnAddedTagsPipe = class UnAddedTagsPipe {
    transform(tagsList, args) {
        const result = [];
        const { tagsAdded, config } = args;
        // if the tagsList is falsy, return empty list
        if (!tagsList) {
            return [];
        }
        // if we have to show selected tags (adds selected: true to every item (or nested tag))
        if (config.showTagsSelectedInDD) {
            tagsList = this.setSelectedTags(tagsList, config, tagsAdded);
        }
        // if we don't have to hide tags, send the tagsList (final, processed) back
        if (!config.hideAddedTags) {
            return tagsList;
        }
        /**
         * if we have to filter out the already selected tags in the dropdown, we'll filter these out
         * and thus the already selected tags won't go back in the results for dropdown
         */
        for (let i = 0, len = tagsList.length; i < len; ++i) {
            const currentTagItem = Object.assign({}, tagsList[i]); // making sure we're not modifying the original object here
            if (!this.isTagAlreadySelected(currentTagItem, tagsAdded, config)) { // if the tag to add isn't added already
                currentTagItem.tiSelected = false;
                if (config.nestedTagProperty && currentTagItem[config.nestedTagProperty]) {
                    currentTagItem[config.nestedTagProperty] = currentTagItem[config.nestedTagProperty].filter((tagItem) => {
                        return !this.isTagAlreadySelected(tagItem, tagsAdded, config);
                    });
                }
                result.push(currentTagItem);
            }
        }
        return result;
    }
    /**
     * @author Ahsan Ayaz
     * @desc Compares a tag against all the tags added based on config provided
     * @param currentTag - the tag to check if it exists in the selection
     * @param tagsAdded - an array of the tags added to the selection
     * @param config - the config provided to the Angular Tags Input component
     * @return boolean - if the tag is added already
     */
    isTagAlreadySelected(currentTag, tagsAdded, config) {
        return tagsAdded.find(tagItem => {
            let matchFound = false;
            matchFound = this.areTagsMatching(currentTag, tagItem, config);
            if (matchFound) {
                return true;
            }
            else if (tagItem[config.nestedTagProperty]) {
                return this.isTagAlreadySelected(currentTag, tagItem[config.nestedTagProperty], config);
            }
            return false;
        });
    }
    /**
     * @author Ahsan Ayaz
     * @desc Compares the two tags based on the identifier provided in the config
     * @param currentTag - the tag in the iteration to compare
     * @param tagItem - the tag (already selected) to compare with
     * @param config - the config provided to the Angular Tags Input component
     * @return boolean - if the tags passed are the same.
     */
    areTagsMatching(currentTag, tagItem, config) {
        if (typeof tagItem[config.identifier] === 'number') {
            // handling if the type of identifier is a number
            return tagItem[config.identifier] === +currentTag[config.identifier];
        }
        else if (typeof tagItem[config.identifier] === 'string' && typeof currentTag[config.identifier] === 'string') {
            // handling if the type of identifier is a string
            return tagItem[config.identifier].toLowerCase() === currentTag[config.identifier].toLowerCase();
        }
    }
    setSelectedTags(tags, config, tagsAdded, isSelected = null) {
        return tags.map(currentTag => {
            currentTag.tiSelected = !!this.isTagAlreadySelected(currentTag, tagsAdded, config);
            if (config.showTagsSelectedInDD && !!isSelected) {
                currentTag.tiSelected = true;
            }
            if (currentTag[config.nestedTagProperty] && currentTag[config.nestedTagProperty].length) {
                currentTag[config.nestedTagProperty] = this.setSelectedTags(currentTag[config.nestedTagProperty], config, tagsAdded, currentTag.tiSelected);
            }
            return currentTag;
        });
    }
};
UnAddedTagsPipe = __decorate([
    Pipe({
        name: 'unAddedTags'
    })
], UnAddedTagsPipe);

let AngularTagsInputService = class AngularTagsInputService {
    constructor() {
        this.debugMode = false;
    }
    /**
     * @author Ahsan Ayaz
     * @desc Finds a tag by Id
     * @param tagsData Array of the tags (could be heirarchical)
     * @param tagId identifier of the tag to be found
     * @param config the tags input config
     * @returns the tag found, or `undefined`
     */
    findTagById(tagsData, tagId, config) {
        for (let i = 0, len = tagsData.length; i < len; ++i) {
            // tslint:disable-next-line:triple-equals
            if (tagsData[i][config.identifier] == tagId) {
                return tagsData[i];
            }
            if (tagsData[i][config.nestedTagProperty]) {
                const nestedParentFound = this.findTagById(tagsData[i][config.nestedTagProperty], tagId, config);
                if (nestedParentFound) {
                    return nestedParentFound;
                }
            }
        }
    }
    setDebugMode(mode) {
        this.debugMode = mode;
    }
    log(logMessage, logLabel = '') {
        if (!this.debugMode) {
            return;
        }
        console.log(logLabel, logMessage);
    }
    findParent(tagsArray, tagItem, config) {
        for (let i = 0, len = tagsArray.length; i < len; ++i) {
            // tslint:disable-next-line:triple-equals
            if (tagsArray[i][config.identifier] == tagItem[config.identifier]) {
                return tagsArray[i];
            }
            if (tagsArray[i][config.nestedTagProperty]) {
                const nestedParentFound = this.findParent(tagsArray[i][config.nestedTagProperty], tagItem, config);
                if (nestedParentFound) {
                    return nestedParentFound;
                }
            }
        }
    }
    getMainTagAfterAdding(tagsArray, tagAdded, tags, config) {
        if (tagAdded[config.nestedTagParentProp]) {
            const parentTag = this.findTagById(tagsArray, tagAdded[config.nestedTagParentProp], config);
            if (!parentTag) {
                return;
            }
            const parentTagChildren = parentTag[config.nestedTagProperty].length;
            const childrensSelected = parentTag[config.nestedTagProperty].filter((tagItem) => {
                // tslint:disable-next-line:triple-equals
                return !!tagItem.tiSelected;
            }).length;
            if (parentTagChildren > 0 && childrensSelected > 0 && childrensSelected === parentTagChildren) {
                parentTag.tiSelected = true;
                if (!parentTag[config.nestedTagParentProp]) {
                    return parentTag;
                }
                else {
                    return this.getMainTagAfterAdding(tagsArray, parentTag, tags, config);
                }
            }
        }
        return tagAdded;
    }
};
AngularTagsInputService.ngInjectableDef = ɵɵdefineInjectable({ factory: function AngularTagsInputService_Factory() { return new AngularTagsInputService(); }, token: AngularTagsInputService, providedIn: "root" });
AngularTagsInputService = __decorate([
    Injectable({
        providedIn: 'root'
    })
], AngularTagsInputService);

let TagInputComponent = class TagInputComponent {
    constructor() {
        this.inputClass = 'default';
        this.disabled = false;
        this.valueChanged = new EventEmitter();
        this.inputFocused = new EventEmitter();
        this.inputBlurred = new EventEmitter();
        this.tagEntered = new EventEmitter();
        this.tagInputForm = new FormGroup({
            tagInputVal: new FormControl('')
        });
    }
    ngOnInit() {
        this.tagInputForm.get('tagInputVal')
            .valueChanges
            .pipe(debounceTime(400), distinctUntilChanged())
            .subscribe((value) => {
            this.lastValueEmitted = value;
            this.valueChanged.emit(value);
        });
    }
    ngOnChanges(changes) {
        if (changes.disabled !== undefined) {
            if (changes.disabled.currentValue === true) {
                this.tagInputForm.get('tagInputVal').disable();
            }
            else {
                this.tagInputForm.get('tagInputVal').enable();
            }
        }
    }
    /**
     * @author Ahsan Ayaz
     * @desc Emits the input focused event with the current search term value
     */
    emitInputFocused() {
        if (this.disabled) {
            return;
        }
        const searchTerm = this.tagInputForm.get('tagInputVal').value;
        this.inputFocused.emit(searchTerm);
        if (this.lastValueEmitted !== searchTerm) {
            this.valueChanged.emit(searchTerm);
            this.lastValueEmitted = searchTerm;
        }
    }
    /**
     * @author Ahsan Ayaz
     * @desc When the user presses enter key after entering the tag name
     * @param inputEl - Reference to the input element so we can fetch the value
     */
    onEnterKeyPress() {
        if (this.config.onlyFromAutoComplete) {
            return;
        }
        const tagName = this.inputEl.nativeElement.value;
        this.tagEntered.emit({
            [this.config.displayProperty]: tagName,
            [this.config.identifier]: tagName.toLowerCase(),
            newTag: true
        });
        this.resetInput();
    }
    /**
     * @author Ahsan Ayaz
     * @desc Resets the input value
     */
    resetInput() {
        this.inputEl.nativeElement.value = '';
    }
    emitInputBlurred($event) {
        this.inputBlurred.emit($event);
    }
};
__decorate([
    Input()
], TagInputComponent.prototype, "inputClass", void 0);
__decorate([
    Input()
], TagInputComponent.prototype, "config", void 0);
__decorate([
    Input()
], TagInputComponent.prototype, "disabled", void 0);
__decorate([
    Output()
], TagInputComponent.prototype, "valueChanged", void 0);
__decorate([
    Output()
], TagInputComponent.prototype, "inputFocused", void 0);
__decorate([
    Output()
], TagInputComponent.prototype, "inputBlurred", void 0);
__decorate([
    Output()
], TagInputComponent.prototype, "tagEntered", void 0);
__decorate([
    ViewChild('inputEl', { static: true })
], TagInputComponent.prototype, "inputEl", void 0);
TagInputComponent = __decorate([
    Component({
        selector: 'ti-tag-input',
        template: "<div class=\"angular-tag-input\" [ngClass]=\"inputClass + ''\">\n  <form no-validate [formGroup]=\"tagInputForm\">\n    <input\n      #inputEl\n      [disabled]=\"disabled\"\n      (keyup.enter)=\"onEnterKeyPress()\"\n      [placeholder]=\"config?.placeholder\"\n      formControlName=\"tagInputVal\"\n      (click)=\"emitInputFocused()\"\n      (focus)=\"emitInputFocused()\"\n      (blur)=\"emitInputBlurred($event)\"\n      class=\"angular-tag-input__input\"\n      autocomplete=\"off\">\n  </form>\n</div>\n",
        styles: [".default .angular-tag-input__input{padding:6px 10px;border:none;width:98%;min-width:100px}.angular-tag-input input:focus{outline-width:0}"]
    })
], TagInputComponent);

const KEY_CODES = {
    ARROW_DOWN: 'ArrowDown',
    ARROW_UP: 'ArrowUp',
    ENTER: 'Enter',
    ESCAPE: 'Escape',
    TAB: 'Tab'
};

let DropdownItemsFilterPipe = class DropdownItemsFilterPipe {
    transform(tagItems = [], config, searchTerm = '') {
        if (!searchTerm) {
            return tagItems;
        }
        return [...tagItems]
            .map((item) => this.getFilteredItem(Object.assign({}, item), config, searchTerm))
            .filter(item => !!item);
    }
    getFilteredItem(item, config, searchTerm = '') {
        if (searchTerm === '') {
            return item;
        }
        let matches = false;
        if (item[config.displayProperty].toLowerCase().includes(searchTerm.toLowerCase())) {
            return item;
        }
        if (item[config.nestedTagProperty]) {
            const childItems = item[config.nestedTagProperty].map(nestedItem => {
                return this.getFilteredItem(nestedItem, config, searchTerm);
            }).filter(nestedItem => !!nestedItem);
            matches = childItems.length > 0;
            if (matches) {
                return Object.assign({}, item, { [config.nestedTagProperty]: [...childItems] });
            }
        }
        return null;
    }
};
DropdownItemsFilterPipe = __decorate([
    Pipe({
        name: 'dropdownItemsFilter'
    })
], DropdownItemsFilterPipe);

let DropdownComponent = class DropdownComponent {
    constructor(tagsInputService) {
        this.tagsInputService = tagsInputService;
        this.listItems = [];
        this.inputVal = '';
        this.itemAdded = new EventEmitter();
        this.itemClicked = new EventEmitter();
        this.dropdownItemsFilter = new DropdownItemsFilterPipe();
        this.identifierSeparator = '__';
        this.itemsMap = new Map();
    }
    ngOnInit() {
        if (!this.dropDownTemplate) {
            // if there's no template provided, assign the default one
            this.dropDownTemplate = this.defaultTagOptionTemplate;
        }
        this.context = {
            items: [...this.listItems],
            config: this.config,
            tagsLoading: this.tagsLoading,
            fns: {
                onItemClicked: this.onItemClicked.bind(this)
            }
        };
        this.keyboardEventsManager = new ListKeyManager([...this.listItems]);
        this.populateItemsMap(this.listItems);
        this.ddIdPrefix = this.getRandomString();
        this.tagsInputService.log(this.itemsMap, 'items populated initially');
    }
    ngOnChanges(changes) {
        if (changes.listItems && !changes.listItems.firstChange) {
            // if the list items change, update the context items (because they're not automatically updated)
            this.filterItems(this.inputVal, changes.listItems.currentValue);
            this.populateItemsMap(changes.listItems ? changes.listItems.currentValue : this.listItems);
        }
        if (changes.inputVal && !changes.inputVal.firstChange) {
            // if the list items change, update the context items (because they're not automatically updated)
            this.filterItems(changes.inputVal.currentValue);
            this.populateItemsMap(changes.listItems ? changes.listItems.currentValue : this.listItems);
        }
    }
    /**
     * @author Ahsan Ayaz
     * @desc Updates the items property for the context provided to the dropdown template
     * @param items - the list of items to be assigned
     */
    filterItems(searchTerm = this.inputVal, items = this.listItems) {
        this.context.items = [...this.dropdownItemsFilter.transform(items, this.config, searchTerm)];
        this.ddIdPrefix = this.getRandomString();
    }
    getRandomString() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    }
    populateItemsMap(items, prefix = null) {
        if (prefix === null) {
            prefix = '';
        }
        else {
            prefix += this.identifierSeparator;
        }
        items.map((item, index) => {
            const newPrefix = prefix + index;
            item.tiIdentifier = newPrefix;
            this.itemsMap[newPrefix] = item;
            if (item[this.config.nestedTagProperty] && item[this.config.nestedTagProperty].length) {
                this.populateItemsMap(item[this.config.nestedTagProperty], newPrefix);
            }
        });
    }
    /**
     * @author Ahsan Ayaz
     * @desc When an option is clicked from the options dropdown
     * @param item - item clicked
     */
    onItemClicked(item, $event = null) {
        if ($event) {
            $event.stopImmediatePropagation(); // for nested items
        }
        this.itemClicked.emit(item);
    }
    handleKeyUp(event) {
        event.stopImmediatePropagation();
        if (!this.keyboardEventsManager) {
            return;
        }
        const isKeyDown = this.isKeyDown(event);
        const isKeyUp = this.isKeyUp(event);
        const isKeyEnter = this.isKeyEnter(event);
        if (isKeyDown || isKeyUp) {
            // passing the event to key manager so we get a change fired
            this.setActiveElement(event);
        }
        else if (isKeyEnter &&
            this.keyboardEventsManager.activeItem) {
            this.itemClicked.emit(this.keyboardEventsManager.activeItem);
        }
    }
    isKeyDown(event) {
        // tslint:disable-next-line: deprecation
        return event.key === KEY_CODES.ARROW_DOWN || event.keyCode === DOWN_ARROW;
    }
    isKeyUp(event) {
        // tslint:disable-next-line: deprecation
        return event.key === KEY_CODES.ARROW_UP || event.keyCode === UP_ARROW;
    }
    isKeyEnter(event) {
        // tslint:disable-next-line: deprecation
        return event.key === KEY_CODES.ENTER || event.keyCode === ENTER;
    }
    setActiveElement(event) {
        const isKeyDown = this.isKeyDown(event);
        const isKeyUp = this.isKeyUp(event);
        const previousActiveItem = Object.assign({}, this.keyboardEventsManager.activeItem);
        if (isKeyDown) {
            this.setNextActiveElement(previousActiveItem, this.listItems);
        }
        else if (isKeyUp) {
            this.setPreviousActiveElement(previousActiveItem, this.listItems);
        }
    }
    setNextActiveElement(currentActiveItem, items) {
        const identifier = currentActiveItem.tiIdentifier;
        if (!identifier) {
            items[0].tiKeyboardActive = true;
            this.keyboardEventsManager.setFirstItemActive();
            return;
        }
        const keyIdentifierArr = identifier.split(this.identifierSeparator);
        let keyIdentifier;
        let treeItems;
        let index;
        keyIdentifier = keyIdentifierArr.length > 1 ?
            [...keyIdentifierArr].splice(0, keyIdentifierArr.length - 1).join(this.identifierSeparator) :
            keyIdentifierArr[0];
        treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}${this.identifierSeparator}`).test(key));
        if (!treeItems.length) {
            treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}$`).test(key));
        }
        index = treeItems.findIndex(id => id === identifier);
        if (index === treeItems.length - 1) {
            this.setActiveElementRecursively(this.findNextParent(keyIdentifierArr), this.listItems);
        }
        else {
            this.setActiveElementRecursively(treeItems[index + 1], this.listItems);
        }
    }
    findNextParent(keyIdentifierArr) {
        let keyIdentifier;
        let treeItems;
        if (keyIdentifierArr.length === 1) {
            const nextIdentifier = `${+keyIdentifierArr[0] + 1}`;
            if (this.itemsMap[nextIdentifier]) {
                return nextIdentifier;
            }
            return keyIdentifierArr[0];
        }
        const nextIdArr = [...keyIdentifierArr].splice(0, keyIdentifierArr.length - 1);
        nextIdArr[nextIdArr.length - 1] = `${(+nextIdArr[nextIdArr.length - 1]) + 1}`;
        keyIdentifier = nextIdArr.join(this.identifierSeparator);
        treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}`).test(key));
        if (treeItems.length) {
            return treeItems[0];
        }
        else {
            return this.findNextParent([...keyIdentifierArr.splice(0, keyIdentifierArr.length - 1)]);
        }
    }
    setPreviousActiveElement(currentActiveItem, items) {
        const identifier = currentActiveItem.tiIdentifier;
        if (!identifier) {
            items[items.length - 1].tiKeyboardActive = true;
            this.keyboardEventsManager.setActiveItem(items[items.length - 1]);
            return;
        }
        const keyIdentifierArr = identifier.split(this.identifierSeparator);
        let keyIdentifier;
        let treeItems;
        let index;
        keyIdentifier = keyIdentifierArr.length > 1 ?
            [...keyIdentifierArr].splice(0, keyIdentifierArr.length - 1).join(this.identifierSeparator) :
            keyIdentifierArr[0];
        treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}(${this.identifierSeparator})?`).test(key));
        if (!treeItems.length) {
            treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}$`).test(key));
        }
        index = treeItems.findIndex(id => id === identifier);
        if (treeItems.length === 1 || index === 0) {
            this.setActiveElementRecursively(this.findPrevousParentLastChild(keyIdentifierArr, identifier), this.listItems);
        }
        else {
            this.setActiveElementRecursively(treeItems[index - 1], this.listItems);
        }
    }
    findPrevousParentLastChild(keyIdentifierArr, prevItemIdentifier) {
        let keyIdentifier;
        const isOnlyItem = keyIdentifierArr.length === 1;
        const prevIdArr = !!isOnlyItem ?
            [...keyIdentifierArr] :
            [...keyIdentifierArr].splice(0, keyIdentifierArr.length - 1);
        prevIdArr[prevIdArr.length - 1] = !!isOnlyItem ? `${(+prevIdArr[prevIdArr.length - 1]) - 1}` : prevIdArr[prevIdArr.length - 1];
        keyIdentifier = prevIdArr.join(this.identifierSeparator);
        let treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}${this.identifierSeparator}`).test(key));
        if (!treeItems.length) {
            treeItems = Object.keys(this.itemsMap).filter(key => new RegExp(`^${keyIdentifier}$`).test(key));
        }
        if (treeItems.length) {
            if (treeItems.indexOf(prevItemIdentifier) !== -1) {
                return keyIdentifier;
            }
            return treeItems[treeItems.length - 1];
        }
        else if (keyIdentifierArr.length > 1) {
            return this.findPrevousParentLastChild([...keyIdentifierArr.splice(0, keyIdentifierArr.length - 1)], prevItemIdentifier);
        }
        else {
            keyIdentifier = keyIdentifierArr.join(this.identifierSeparator);
            return keyIdentifier;
        }
    }
    setActiveElementRecursively(identifier, items) {
        for (let i = 0, len = items.length; i < len; ++i) {
            items[i].tiKeyboardActive = false;
            if (items[i].tiIdentifier === identifier) {
                this.keyboardEventsManager = new ListKeyManager([...items]);
                items[i].tiKeyboardActive = true; // select next item
                this.keyboardEventsManager.setActiveItem(items[i]);
            }
            if (items[i][this.config.nestedTagProperty] && items[i][this.config.nestedTagProperty].length) {
                this.setActiveElementRecursively(identifier, items[i][this.config.nestedTagProperty]);
            }
        }
    }
};
DropdownComponent.ctorParameters = () => [
    { type: AngularTagsInputService }
];
__decorate([
    Input()
], DropdownComponent.prototype, "config", void 0);
__decorate([
    Input()
], DropdownComponent.prototype, "listItems", void 0);
__decorate([
    Input()
], DropdownComponent.prototype, "inputVal", void 0);
__decorate([
    Input()
], DropdownComponent.prototype, "dropDownTemplate", void 0);
__decorate([
    Input()
], DropdownComponent.prototype, "tagsLoading", void 0);
__decorate([
    Input()
], DropdownComponent.prototype, "keyPress", void 0);
__decorate([
    Output()
], DropdownComponent.prototype, "itemAdded", void 0);
__decorate([
    Output()
], DropdownComponent.prototype, "itemClicked", void 0);
__decorate([
    ViewChild('defaultTagOptionTemplate', { static: true })
], DropdownComponent.prototype, "defaultTagOptionTemplate", void 0);
DropdownComponent = __decorate([
    Component({
        selector: 'ti-dropdown',
        template: "\n<ng-container\n *ngTemplateOutlet=\"dropDownTemplate; context: context\">\n</ng-container>\n\n<!-- Default Tag Options Template -->\n<ng-template #defaultTagOptionTemplate let-items=\"items\" let-config=\"config\">\n  <div class=\"angular-tags-dropdown\">\n    <div class=\"angular-tags-dropdown__list\">\n      <ng-container *ngFor=\"let item of items, let i = index\">\n        <div\n          class=\"angular-tags-dropdown__list__item\"\n          (click)=\"onItemClicked(item)\"\n          tiKeyboardActiveClass=\"angular-tags-dropdown__list__item--active\"\n          [isKeyboardActiveItem]=\"item.tiKeyboardActive\"\n          >\n          {{item[config.displayProperty]}}\n        </div>\n      </ng-container>\n    </div>\n  </div>\n</ng-template>\n",
        styles: [":host{display:block}:host .angular-tags-dropdown{padding:8px 10px}:host .angular-tags-dropdown__list__item{padding:8px 10px;cursor:pointer;transition:.5s}:host .angular-tags-dropdown__list__item:hover{background:#dcdcdc}:host .angular-tags-dropdown__list__item--active{background:#333;color:#fff}"]
    })
], DropdownComponent);

let AngularTagsInputComponent = class AngularTagsInputComponent {
    constructor(sso, tagsService) {
        this.sso = sso;
        this.tagsService = tagsService;
        this.tagsData = [];
        this.disabled = false;
        this.dropDownTemplate = null;
        this.tagItemTemplate = null;
        this.required = false;
        this.tagRemoved = new EventEmitter();
        this.tagAdded = new EventEmitter();
        this.valueChanged = new EventEmitter();
        this.itemClicked = new EventEmitter();
        this.tags = [];
        this.defaultConfig = {
            defaultClass: 'angular-tags-input',
            additionalClasses: '',
            displayProperty: 'value',
            identifier: 'id',
            onlyFromAutoComplete: false,
            placeholder: 'Search',
            hideAddedTags: true,
            nestedTagProperty: '',
            showTagsSelectedInDD: false,
            hideTags: false,
            maxItems: null,
            nestedTagParentProp: '',
            keyboardActiveClass: 'angular-tags-dropdown__list__item--active'
        };
        this.dropdownOverlayPosition = [
            { offsetY: 12, originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },
            { offsetY: -28, originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom' },
            { offsetY: 28, originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'bottom' },
            { offsetY: -28, originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom' },
        ];
        this.unAddedTagsPipe = new UnAddedTagsPipe();
    }
    keyEvent(event) {
        this.inputKeyPress(event);
    }
    ngOnChanges(changes) {
        // if there's no change in the tagsData, do nothing
        if (!changes.tagsData || !this.isInputFocused) {
            return;
        }
        // If the previous walue was `null` or `undefined`, we're initializing that as an array here
        // so we can avoid breaking the process further.
        if (!changes.tagsData.previousValue) {
            changes.tagsData.previousValue = [];
        }
        // if we have the value of the tags changed, we need to show the dropdown immediately
        // we don't show this on the first change, because that's when the first value is assigned
        if (changes.tagsData && changes.tagsData.currentValue !== changes.tagsData.previousValue
            && !changes.tagsData.firstChange) {
            // if the values don't match, show the dropdown
            if (changes.tagsData.currentValue.length !== changes.tagsData.previousValue.length && !!this.dropdownShownYet) {
                return this.showDropdown(changes.tagsData.currentValue);
            }
            if (changes.tagsData.previousValue.length === 0) {
                return;
            }
            /* since the values are array, we need to compare the elements within
             * avoiding the usage of any external library, matching the elements using identifier
             * of the elements here
             */
            for (let i = 0, len = changes.tagsData.currentValue.length; i < len; ++i) {
                if (changes.tagsData.currentValue[i][this.config.identifier] !== changes.tagsData.previousValue[i][this.config.identifier]) {
                    // as soon as the difference in elements is found, show the element and stop further execution of for loop
                    return this.showDropdown(changes.tagsData.currentValue);
                }
            }
        }
    }
    onFocusChange(val) {
        this.isInputFocused = val;
        if (!val && this.config.hideDDOnBlur) {
            setTimeout(() => {
                this.hideDropdown();
            }, 400);
        }
    }
    onInputValueChanged(val) {
        this.inputVal = val;
        this.valueChanged.emit(val);
    }
    ngOnInit() {
        this.config = Object.assign({}, this.defaultConfig, this.config);
        this.ddScrollStrategy = this.sso.reposition();
    }
    /**
     * @author Ahsan Ayaz
     * @desc Triggers when the value of the form control (or ngModel) is changed.
     * We're using the handler to assign the values to the tags array that we have.
     */
    writeValue(tags) {
        tags = tags ? tags : [];
        tags = Array.isArray(tags) ? tags : [tags];
        this.tags = tags.map((tag) => {
            return Object.assign({}, tag, {
                [this.config.identifier]: tag[this.config.identifier],
                [this.config.displayProperty]: tag[this.config.displayProperty],
            });
        });
        if (this.config.showTagsSelectedInDD) {
            setTimeout(() => {
                this.tags.map((tag) => {
                    this.selectRelatedTags(tag);
                });
            });
        }
    }
    /**
     * @author Ahsan Ayaz
     * @desc Registers the on change function to the value accessor
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Validator function for the form control
     * Doesn't do anything if the control is not required
     * If it is required, checks if the control contains value
     */
    validate(control) {
        if (this.required === false) {
            return null;
        }
        return (!!control.value && control.value.length) ? null : {
            required: true,
        };
    }
    /**
     * @author Ahsan Ayaz
     * @desc Triggers when the tag input is focused
     */
    onInputFocus() {
        if (this.config.clearInputOnFocus) {
            if (this.tagInput.lastValueEmitted !== '') {
                this.tagInput.tagInputForm.get('tagInputVal').setValue('');
            }
            this.tagInput.resetInput();
        }
        if (this.config.clearTagsOnFocus) {
            this.tags.length = 0;
        }
        this.showDropdown();
        this.onFocusChange(true);
    }
    /**
     * @author Ahsan Ayaz
     * @desc Shows the dropdown with options listing
     */
    showDropdown(recentTags = null) {
        const unAddedTags = this.unAddedTagsPipe.transform(!!recentTags ? recentTags : this.tagsData, {
            tagsAdded: this.tags,
            config: this.config
        });
        if (unAddedTags.length) { // only show dropdown when we have data to show
            this.isDropdownOpen = true;
        }
        if (!this.dropdownShownYet) {
            this.dropdownShownYet = true;
        }
    }
    /**
     * @author Ahsan Ayaz
     * @desc Hides the options listing dropdown
     */
    hideDropdown() {
        this.isDropdownOpen = false;
        this.tagsData = this.removeKeyboardSelection(this.tagsData);
    }
    removeKeyboardSelection(items) {
        return items.map((tag) => {
            if (tag[this.config.nestedTagProperty] && tag[this.config.nestedTagProperty].length) {
                tag[this.config.nestedTagProperty] = this.removeKeyboardSelection(tag[this.config.nestedTagProperty]);
            }
            return Object.assign({}, tag, { tiKeyboardActive: false });
        });
    }
    ngAfterViewInit() {
        if (!!this.config || !this.onChange) {
            console.warn('Please use ngModel or FormControlName with <ti-angular-tags-input>');
        }
        if (this.config.nestedTagProperty) {
            // we need the parent property to be able to unselect the parent when a child tag is unselected
            if (!this.config.nestedTagParentProp) {
                // tslint:disable-next-line:max-line-length
                throw new Error('nestedTagProperty provided but nestedTagParentProp not provided.\nThis will cause the parent tag to not remove if any of the children is removed');
            }
        }
    }
    /**
     * @author Ahsan Ayaz
     * @desc Adds the tag in the tags list (tags array).
     * Avoids duplicate tags addition
     * @param tag - tag to add
     */
    addTag(tag) {
        if (this.config.showTagsSelectedInDD) {
            tag.tiSelected = true; // marks the element as selected
        }
        if (this.config.maxItems > 0 && this.tags.length === this.config.maxItems) {
            return;
        }
        if (!this.tags.find(tagItem => tagItem[this.config.identifier] === tag[this.config.identifier])) {
            this.tags = [...this.tags, tag];
            this.onChange(this.tags);
        }
    }
    /**
     * @author Ahsan Ayaz
     * @desc Removes the tags from the tags list
     * @param tag - tag to remove
     */
    removeTag(tag) {
        this.tags = this.tags.filter((tagItem) => tagItem[this.config.identifier] !== tag[this.config.identifier]);
        // when we've removed all the tags, we want to get the default tags
        if (this.tags.length === 0) {
            this.tagInput.resetInput();
            this.valueChanged.emit('');
        }
        this.onChange(this.tags);
    }
    /**
     * @author Ahsan Ayaz
     * @desc Triggers when the item is clicked from the dropdown
     * @param tag - tag selected
     */
    onItemClicked(tag) {
        // if we don't have to toggle, add the item as tag right away
        if (this.config.toggleSelectionOnClick) {
            // we have to toggle selection. First, let's see if the tag doesn't exist already in the selected tags
            if (!tag.tiSelected && !this.tags.find(tagItem => tagItem[this.config.identifier] === tag[this.config.identifier])) {
                this.addTag(tag);
                this.selectRelatedTags(tag);
                this.tagAdded.emit(this.tagsService.getMainTagAfterAdding(this.tagsData, tag, this.tags, this.config));
            }
            else { // if the tag is already selected, remove
                this.removeTag(tag);
                this.removeTagSelection(tag);
                this.tagRemoved.emit(tag);
            }
        }
        else {
            this.addTag(tag);
            this.selectRelatedTags(tag);
            this.tagAdded.emit(this.tagsService.getMainTagAfterAdding(this.tagsData, tag, this.tags, this.config));
        }
        this.tagInput.resetInput();
        this.itemClicked.emit(tag);
        this.hideDropdown();
    }
    /**
     * @author Ahsan Ayaz
     * @desc Removes the tag seleced state (and of the children)
     * @param tag - the tag to unmark as selected
     */
    removeTagSelection(tag, ignoreChildren = false, ignoreParent = false) {
        tag.tiSelected = false;
        if (!ignoreChildren && tag[this.config.nestedTagProperty]) {
            for (let i = 0, len = tag[this.config.nestedTagProperty].length; i < len; ++i) {
                this.removeTag(tag[this.config.nestedTagProperty][i]);
                this.removeTagSelection(tag[this.config.nestedTagProperty][i], ignoreChildren);
            }
        }
        if (tag[this.config.nestedTagParentProp] && !ignoreParent) {
            const parentTag = this.tagsService.findTagById(this.tagsData, tag[this.config.nestedTagParentProp], this.config);
            if (parentTag && parentTag.tiSelected) {
                this.removeTag(parentTag);
                this.removeTagSelection(parentTag, true, ignoreParent);
                parentTag[this.config.nestedTagProperty].map((tagItem) => {
                    // tslint:disable-next-line:triple-equals
                    if (tagItem[this.config.identifier] != tag[this.config.identifier]) {
                        this.addTag(tagItem);
                        this.selectRelatedTags(tagItem, false, true);
                    }
                });
            }
        }
        this.onChange(this.tags);
    }
    /**
     * @author Ahsan Ayaz
     * @desc triggers on close button click of the tags
     * @param tag - the tag to remove
     */
    tagCloseClicked(tag) {
        this.tagRemoved.emit(tag);
        this.removeTag(tag);
        this.removeTagSelection(tag);
    }
    /**
     * @author Ahsan Ayaz
     * @desc Selects/adds the retated tags (parent and/or children)
     * @param tag - the tag to mark as selected
     */
    selectRelatedTags(tag, ignoreChildren = false, ignoreParent = false) {
        if (this.config.showTagsSelectedInDD) {
            tag.tiSelected = true;
        }
        if (tag[this.config.nestedTagProperty] && !ignoreChildren) {
            for (let i = 0, len = tag[this.config.nestedTagProperty].length; i < len; ++i) {
                if (this.config.showParentTagsOnly) {
                    // remove the children if we only have to keep parent
                    this.removeTag(tag[this.config.nestedTagProperty][i]);
                    // making sure we're targeting only children, ignoring parents
                    this.selectRelatedTags(tag[this.config.nestedTagProperty][i], false, true);
                }
                else {
                    this.addTag(tag[this.config.nestedTagProperty][i]);
                }
            }
        }
        if (tag[this.config.nestedTagParentProp] && !ignoreParent) {
            const parentTag = this.tagsService.findTagById(this.tagsData, tag[this.config.nestedTagParentProp], this.config);
            if (!parentTag) {
                return;
            }
            const parentTagChildren = parentTag[this.config.nestedTagProperty].length;
            const childrensSelected = this.tags.filter((tagItem) => {
                // tslint:disable-next-line:triple-equals
                return tagItem[this.config.nestedTagParentProp] == parentTag[this.config.identifier];
            }).length;
            if ((parentTagChildren > 0 && childrensSelected > 0) &&
                (this.config.childrenCountProperty ?
                    childrensSelected === parentTag[this.config.childrenCountProperty] :
                    childrensSelected === parentTagChildren)) {
                this.addTag(parentTag);
                this.selectRelatedTags(parentTag, false, false);
            }
        }
        this.onChange(this.tags);
    }
    registerOnTouched(fn) {
        // throw new Error("Method not implemented.");
    }
    inputKeyPress($event) {
        $event.stopImmediatePropagation();
        if (!this.isDropdownOpen &&
            ($event.key === KEY_CODES.ARROW_UP ||
                $event.key === KEY_CODES.ARROW_DOWN)) {
            this.isDropdownOpen = true;
        }
        else if (this.isDropdownOpen &&
            $event.key === KEY_CODES.ESCAPE) {
            return this.hideDropdown();
        }
        // so we have the dropdown shown
        setTimeout(() => {
            if (this.dropdown) {
                this.dropdown.handleKeyUp($event);
            }
        }, 10);
    }
};
AngularTagsInputComponent.ctorParameters = () => [
    { type: ScrollStrategyOptions },
    { type: AngularTagsInputService }
];
__decorate([
    ViewChild(DropdownComponent, { static: false })
], AngularTagsInputComponent.prototype, "dropdown", void 0);
__decorate([
    Input()
], AngularTagsInputComponent.prototype, "config", void 0);
__decorate([
    Input()
], AngularTagsInputComponent.prototype, "tagsData", void 0);
__decorate([
    Input()
], AngularTagsInputComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], AngularTagsInputComponent.prototype, "tagsLoading", void 0);
__decorate([
    Input()
], AngularTagsInputComponent.prototype, "dropDownTemplate", void 0);
__decorate([
    Input()
], AngularTagsInputComponent.prototype, "tagItemTemplate", void 0);
__decorate([
    Input()
], AngularTagsInputComponent.prototype, "required", void 0);
__decorate([
    Output()
], AngularTagsInputComponent.prototype, "tagRemoved", void 0);
__decorate([
    Output()
], AngularTagsInputComponent.prototype, "tagAdded", void 0);
__decorate([
    Output()
], AngularTagsInputComponent.prototype, "valueChanged", void 0);
__decorate([
    Output()
], AngularTagsInputComponent.prototype, "itemClicked", void 0);
__decorate([
    ViewChild(TagInputComponent, { static: true })
], AngularTagsInputComponent.prototype, "tagInput", void 0);
__decorate([
    HostListener('keyup', ['$event'])
], AngularTagsInputComponent.prototype, "keyEvent", null);
AngularTagsInputComponent = __decorate([
    Component({
        selector: 'ti-angular-tags-input',
        template: "<div\n  class=\"angular-tags-input\"\n  [ngClass]=\"config.defaultClass + ' ' + config.additionalClasses\">\n  <div class=\"angular-tags-input__inp-container\" #dropdownTrigger=\"cdkOverlayOrigin\" cdkOverlayOrigin>\n    <ng-container *ngIf=\"!config.hideTags\">\n      <ti-tag\n        class=\"angular-tags-input__inp-container__tag\"\n        *ngFor=\"let tagItem of tags\"\n        [config]=\"config\"\n        [tagItem]=\"tagItem\"\n        [tagItemTemplate]=\"tagItemTemplate\"\n        (closeClicked)=\"tagCloseClicked($event)\">\n      </ti-tag>\n    </ng-container>\n    <ti-tag-input\n      [style.display]=\"config.hideInputOnSelection && tags.length ? 'none' : 'block'\"\n      [config]=\"config\"\n      [disabled]=\"disabled\"\n      class=\"angular-tags-input__inp-container__tag-input\"\n      (tagEntered)=\"addTag($event)\"\n      (valueChanged)=\"onInputValueChanged($event)\"\n      (inputFocused)=\"onInputFocus()\"\n      (inputBlurred)=\"onFocusChange(false);\"\n      (inputKeyPress)=\"inputKeyPress($event)\">\n    </ti-tag-input>\n  </div>\n  \n  <ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]=\"dropdownTrigger\" [cdkConnectedOverlayOpen]=\"isDropdownOpen\"\n    [cdkConnectedOverlayHasBackdrop]=\"config.ddHasBackdrop\" (backdropClick)=\"hideDropdown()\"\n    [cdkConnectedOverlayPanelClass]=\"'angular-tags-input-dd-overlay' + config.dropdownClass ? config.dropdownClass : ''\"\n    [cdkConnectedOverlayScrollStrategy]=\"ddScrollStrategy\"\n    [cdkConnectedOverlayPositions]=\"dropdownOverlayPosition\"\n    [cdkConnectedOverlayMinWidth]=\"310\">\n    <div class=\"angular-tags-input__dd-container\">\n      <ti-dropdown\n        [inputVal]=\"inputVal\"\n        (itemClicked)=\"onItemClicked($event);\"\n        [dropDownTemplate]=\"dropDownTemplate\"\n        [listItems]=\"tagsData | unAddedTags: {tagsAdded: tags, config: config}\"\n        [config]=\"config\"\n        (itemAdded)=\"addTag($event);\">\n      </ti-dropdown>\n    </div>\n  </ng-template>\n</div>\n",
        providers: [
            getAngularTagsInputValueAccessor(),
            getAngularTagsInputValidatorsProvider()
        ],
        encapsulation: ViewEncapsulation.None,
        styles: ["ti-angular-tags-input{display:block;width:100%}.angular-tags-input{display:flex;flex-direction:row;align-items:center;margin:-3px 0}.angular-tags-input__inp-container{width:100%;display:flex;flex-direction:row;align-items:center;background:#fff;flex-wrap:wrap;padding:9px 18px 18px;position:relative;top:4px}.angular-tags-input__inp-container__tag-input{flex:1}.angular-tags-input__inp-container__tag{margin:0 10px 8px 0}.angular-tags-input__dd-container{display:block;width:100%}.cdk-overlay-container.select-assignee-overlay{z-index:1050}.cdk-overlay-container.task-menu-popover-overlay{z-index:2050}.duplicate-modal-overlay{z-index:999}.cdk-overlay-backdrop{display:block}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{display:block;position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;background-color:#fff;z-index:1000;display:flex;max-width:100%;max-height:100%;border:1px solid #fff;box-shadow:0 2px 14px 4px rgba(0,0,0,.1)}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}"]
    })
], AngularTagsInputComponent);
function getAngularTagsInputValueAccessor() {
    return {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => AngularTagsInputComponent),
        multi: true,
    };
}
function getAngularTagsInputValidatorsProvider() {
    return {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => AngularTagsInputComponent),
        multi: true,
    };
}

let TagComponent = class TagComponent {
    constructor() {
        this.tagClass = 'default-tag';
        this.closeClicked = new EventEmitter();
    }
    ngOnInit() {
        if (!this.tagItemTemplate) { // if there's no template provided, assign the default one
            this.tagItemTemplate = this.defaultTagItemTemplate;
        }
        this.context = {
            item: this.tagItem,
            config: this.config,
            tagClass: this.tagClass,
            closeClicked: this.closeClicked
        };
    }
};
__decorate([
    Input()
], TagComponent.prototype, "config", void 0);
__decorate([
    Input()
], TagComponent.prototype, "tagItem", void 0);
__decorate([
    Input()
], TagComponent.prototype, "tagClass", void 0);
__decorate([
    Input()
], TagComponent.prototype, "tagItemTemplate", void 0);
__decorate([
    Output()
], TagComponent.prototype, "closeClicked", void 0);
__decorate([
    ViewChild('defaultTagItemTemplate', { static: true })
], TagComponent.prototype, "defaultTagItemTemplate", void 0);
TagComponent = __decorate([
    Component({
        selector: 'ti-tag',
        template: "\n<ng-container\n *ngTemplateOutlet=\"tagItemTemplate; context: context;\">\n</ng-container>\n\n<!-- Default Tag Options Template -->\n<ng-template #defaultTagItemTemplate let-item=\"item\" let-tagClass=\"tagClass\" let-config=\"config\" let-closeClicked=\"closeClicked\">\n  <div class=\"angular-tag\" [ngClass]=\"tagClass + ''\">\n    <div class=\"angular-tag__text\" *ngIf=\"config\">\n      {{item[config.displayProperty]}}\n    </div>\n    <button type=\"button\" class=\"angular-tag__close-btn\" (click)=\"closeClicked.emit(item)\">\n      x\n    </button>\n  </div>\n</ng-template>\n\n\n",
        styles: [".angular-tag{display:flex;align-items:center}.angular-tag__text{margin-right:10px;flex:1}.default-tag .angular-tag__text{color:#fff}.angular-tag__close-btn{cursor:pointer}.default-tag .angular-tag__close-btn{padding-left:0;padding-right:0;background:0 0;border:none;color:#fff}.default-tag .angular-tag__close-btn:hover{color:#dcdcdc}.angular-tag.default-tag{background:#344860;padding:6px 10px;transition:.5s}.angular-tag.default-tag:hover{background:#333}"]
    })
], TagComponent);

let KeyboardActiveClassDirective = class KeyboardActiveClassDirective {
    constructor(el, cdRef) {
        this.el = el;
        this.cdRef = cdRef;
        this.isKeyboardActiveItem = false;
    }
    ngOnInit() {
        if (!this.tiKeyboardActiveClass) {
            console.warn('tiKeyboardActiveClass needs a class to apply. But no class was passed.');
        }
    }
    ngOnChanges(simpleChanges) {
        if (!simpleChanges.isKeyboardActiveItem) {
            return;
        }
        if (simpleChanges.isKeyboardActiveItem.currentValue !== simpleChanges.isKeyboardActiveItem.previousValue) {
            this.evaluateClassApplication();
        }
    }
    evaluateClassApplication() {
        if (this.isKeyboardActiveItem) {
            this.el.nativeElement.classList.add(this.tiKeyboardActiveClass);
            this.el.nativeElement.scrollIntoView(false);
        }
        else {
            this.el.nativeElement.classList.remove(this.tiKeyboardActiveClass);
        }
        this.cdRef.markForCheck();
    }
};
KeyboardActiveClassDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], KeyboardActiveClassDirective.prototype, "isKeyboardActiveItem", void 0);
__decorate([
    Input()
], KeyboardActiveClassDirective.prototype, "tiKeyboardActiveClass", void 0);
KeyboardActiveClassDirective = __decorate([
    Directive({
        selector: '[tiKeyboardActiveClass]'
    })
], KeyboardActiveClassDirective);

let AngularTagsInputModule = class AngularTagsInputModule {
};
AngularTagsInputModule = __decorate([
    NgModule({
        declarations: [
            AngularTagsInputComponent,
            TagComponent,
            TagInputComponent,
            DropdownComponent,
            UnAddedTagsPipe,
            DropdownItemsFilterPipe,
            KeyboardActiveClassDirective
        ],
        imports: [
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            OverlayModule
        ],
        exports: [AngularTagsInputComponent, KeyboardActiveClassDirective]
    })
], AngularTagsInputModule);

/*
 * Public API Surface of angular-tags-input
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AngularTagsInputComponent, AngularTagsInputModule, AngularTagsInputService, KeyboardActiveClassDirective, UnAddedTagsPipe, getAngularTagsInputValidatorsProvider, getAngularTagsInputValueAccessor, DropdownComponent as ɵa, TagInputComponent as ɵb, TagComponent as ɵc, DropdownItemsFilterPipe as ɵd };
//# sourceMappingURL=iomechs-angular-tags-input.js.map
