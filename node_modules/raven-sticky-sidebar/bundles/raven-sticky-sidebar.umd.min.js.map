{"version":3,"sources":["ng://raven-sticky-sidebar/lib/sticky-sidebar.service.ts","ng://raven-sticky-sidebar/lib/sticky-sidebar.component.ts","ng://raven-sticky-sidebar/lib/sticky-sidebar.module.ts"],"names":["StickySidebarService","Injectable","args","providedIn","StickySidebarComponent","_hostElementRef","this","customTopOffset","_containerElement","document","documentElement","_scrollTop","_scrollDirection","Object","defineProperty","prototype","value","querySelector","_wrapperElement","reset","ngOnInit","wrapperElementRef","addScrollListener","addResizeListener","style","minHeight","setSidebarHeight","initTopOffset","scrollTop","height","containerHeight","hostElement","getComputedStyle","cssFloat","parentElement","offsetHeight","getContentBoxHeight","newContainerHeight","topOffset","_initialTopOffset","top","_this","window","addEventListener","requestAnimationFrame","parseInt","newScrollTop","scrollDistance","element","limitToViewport","styles","clientHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","Component","selector","template","ElementRef","Input","ViewChild","static","StickySidebarModule","NgModule","declarations","imports","exports"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class StickySidebarService {\n\n  constructor() { }\n}\n","import { Component, OnInit, ElementRef, ViewChild, Input } from '@angular/core';\n\n@Component({\n  selector: 'raven-sticky-sidebar',\n  template: `<div #wrapper class=\"ss-wrapper\"><ng-content></ng-content></div>`,\n  styleUrls: ['sticky-sidebar.component.css']\n})\nexport class StickySidebarComponent implements OnInit {\n  @Input('topOffset')\n  customTopOffset: number;\n\n  @ViewChild('wrapper', { static: true })\n  wrapperElementRef: ElementRef;\n\n  private _containerElement: HTMLElement;\n  private _wrapperElement: HTMLDivElement;\n  private _initialTopOffset: number;\n  private _scrollTop: number;\n  private _scrollDirection: 'up' | 'down'\n\n  constructor(\n    private _hostElementRef: ElementRef\n  ) {\n    this.customTopOffset = 0;\n    this._containerElement = document.documentElement;\n    this._scrollTop = 0;\n    this._scrollDirection = 'down';\n  }\n\n  @Input('container')\n  set containerSelector(value: string) {\n    this._containerElement = document.querySelector(value);\n\n    if (this._wrapperElement) {\n      this.reset();\n    }\n  }\n\n  ngOnInit() {\n    this._wrapperElement = <HTMLDivElement>this.wrapperElementRef.nativeElement;\n\n    this.reset();\n    this.addScrollListener();\n    this.addResizeListener();\n  }\n\n  /**\n   * Resets sidebar based on current conditions.\n   */\n  reset() {\n    const hostElement = <HTMLDivElement>this._hostElementRef.nativeElement;\n\n    hostElement.style.minHeight = '0';\n\n    this.setSidebarHeight();\n    this.initTopOffset();\n\n    this._scrollTop = this._containerElement.scrollTop;\n  }\n\n  /**\n   * Ensures the minimum height of the sidebar is the same as the container\n   * when floats are used.\n   */\n  setSidebarHeight(height?: number) {\n    const hostElement = <HTMLDivElement>this._hostElementRef.nativeElement;\n\n    if (getComputedStyle(hostElement).cssFloat === 'none') {\n      return;\n    }\n\n    let containerHeight: number;\n\n    if (height) {\n      containerHeight = height;\n    } else {\n      containerHeight = (this._containerElement === document.documentElement) ?\n        hostElement.parentElement.offsetHeight :\n        this.getContentBoxHeight(this._containerElement);\n    }\n\n    hostElement.style.minHeight = containerHeight + 'px';\n\n    if (this._containerElement !== document.documentElement) {\n      // Height change may have changed container height\n      const newContainerHeight = this.getContentBoxHeight(this._containerElement);\n\n      if (hostElement.offsetHeight < newContainerHeight) {\n        this.setSidebarHeight(newContainerHeight);\n      }\n    }\n  }\n\n  /**\n   * Initializes the \"top\" CSS property of the wrapper element.\n   */\n  initTopOffset() {\n    // Measure container and wrapper height\n    const containerHeight = this.getContentBoxHeight(this._containerElement, true);\n    const wrapperHeight = this._wrapperElement.offsetHeight;\n\n    // Set top offset\n    const topOffset = (wrapperHeight - containerHeight) * -1;\n\n    this._initialTopOffset = (topOffset < this.customTopOffset) ?\n      topOffset :\n      this.customTopOffset;\n    this._wrapperElement.style.top = this._initialTopOffset + 'px';\n  }\n\n  /**\n   * Watches the scroll event and adjusts the \"top\" CSS property of the wrapper\n   * element.\n   */\n  addScrollListener() {\n    const scrollElement = (this._containerElement === document.documentElement) ?\n      window :\n      this._containerElement;\n\n    scrollElement.addEventListener('scroll', () => {\n      requestAnimationFrame(() => {\n        const topOffset = parseInt(this._wrapperElement.style.top);\n\n        const newScrollTop = this._containerElement.scrollTop;\n        const scrollDistance = newScrollTop - this._scrollTop;\n\n        this._scrollDirection = (scrollDistance > 0) ? 'down' : 'up';\n        this._scrollTop = this._containerElement.scrollTop;\n\n        if (this._scrollDirection === 'down') {\n          if (topOffset - scrollDistance <= this._initialTopOffset) {\n            this._wrapperElement.style.top = this._initialTopOffset + 'px';\n          } else {\n            this._wrapperElement.style.top =\n              (topOffset - scrollDistance) + 'px';\n          }\n        } else {\n          if (topOffset - scrollDistance >= this.customTopOffset) {\n            this._wrapperElement.style.top = this.customTopOffset + 'px';\n          } else if (newScrollTop > -this._initialTopOffset) {\n            this._wrapperElement.style.top = (topOffset - scrollDistance) + 'px';\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Watches the window.resize event and resets sidebar.\n   */\n  addResizeListener() {\n    window.addEventListener('resize', () => {\n      requestAnimationFrame(() => this.reset());\n    });\n  }\n\n  /**\n   * Returns the height of an element without padding or borders.\n   * @param element The element to use.\n   * @param limitToViewport Whether to use the full height or limit the height\n   *                        to the height of the viewport.\n   */\n  getContentBoxHeight(element: HTMLElement, limitToViewport = false): number {\n    const styles = getComputedStyle(element);\n    const outerHeight = (limitToViewport) ?\n      element.clientHeight :\n      element.offsetHeight;\n    const padding = parseInt(styles.paddingTop) +\n      parseInt(styles.paddingBottom);\n    const borders = parseInt(styles.borderTopWidth) +\n      parseInt(styles.borderBottomWidth);\n    const innerHeight = outerHeight - padding - borders;\n\n    return innerHeight;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { StickySidebarComponent } from './sticky-sidebar.component';\n\n@NgModule({\n  declarations: [StickySidebarComponent],\n  imports: [\n  ],\n  exports: [StickySidebarComponent]\n})\nexport class StickySidebarModule { }\n"]}