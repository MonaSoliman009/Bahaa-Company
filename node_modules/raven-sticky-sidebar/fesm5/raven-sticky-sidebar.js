import { ɵɵdefineInjectable, Injectable, Component, ElementRef, Input, ViewChild, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StickySidebarService = /** @class */ (function () {
    function StickySidebarService() {
    }
    StickySidebarService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    StickySidebarService.ctorParameters = function () { return []; };
    /** @nocollapse */ StickySidebarService.ngInjectableDef = ɵɵdefineInjectable({ factory: function StickySidebarService_Factory() { return new StickySidebarService(); }, token: StickySidebarService, providedIn: "root" });
    return StickySidebarService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StickySidebarComponent = /** @class */ (function () {
    function StickySidebarComponent(_hostElementRef) {
        this._hostElementRef = _hostElementRef;
        this.customTopOffset = 0;
        this._containerElement = document.documentElement;
        this._scrollTop = 0;
        this._scrollDirection = 'down';
    }
    Object.defineProperty(StickySidebarComponent.prototype, "containerSelector", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._containerElement = document.querySelector(value);
            if (this._wrapperElement) {
                this.reset();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    StickySidebarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._wrapperElement = (/** @type {?} */ (this.wrapperElementRef.nativeElement));
        this.reset();
        this.addScrollListener();
        this.addResizeListener();
    };
    /**
     * Resets sidebar based on current conditions.
     */
    /**
     * Resets sidebar based on current conditions.
     * @return {?}
     */
    StickySidebarComponent.prototype.reset = /**
     * Resets sidebar based on current conditions.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var hostElement = (/** @type {?} */ (this._hostElementRef.nativeElement));
        hostElement.style.minHeight = '0';
        this.setSidebarHeight();
        this.initTopOffset();
        this._scrollTop = this._containerElement.scrollTop;
    };
    /**
     * Ensures the minimum height of the sidebar is the same as the container
     * when floats are used.
     */
    /**
     * Ensures the minimum height of the sidebar is the same as the container
     * when floats are used.
     * @param {?=} height
     * @return {?}
     */
    StickySidebarComponent.prototype.setSidebarHeight = /**
     * Ensures the minimum height of the sidebar is the same as the container
     * when floats are used.
     * @param {?=} height
     * @return {?}
     */
    function (height) {
        /** @type {?} */
        var hostElement = (/** @type {?} */ (this._hostElementRef.nativeElement));
        if (getComputedStyle(hostElement).cssFloat === 'none') {
            return;
        }
        /** @type {?} */
        var containerHeight;
        if (height) {
            containerHeight = height;
        }
        else {
            containerHeight = (this._containerElement === document.documentElement) ?
                hostElement.parentElement.offsetHeight :
                this.getContentBoxHeight(this._containerElement);
        }
        hostElement.style.minHeight = containerHeight + 'px';
        if (this._containerElement !== document.documentElement) {
            // Height change may have changed container height
            /** @type {?} */
            var newContainerHeight = this.getContentBoxHeight(this._containerElement);
            if (hostElement.offsetHeight < newContainerHeight) {
                this.setSidebarHeight(newContainerHeight);
            }
        }
    };
    /**
     * Initializes the "top" CSS property of the wrapper element.
     */
    /**
     * Initializes the "top" CSS property of the wrapper element.
     * @return {?}
     */
    StickySidebarComponent.prototype.initTopOffset = /**
     * Initializes the "top" CSS property of the wrapper element.
     * @return {?}
     */
    function () {
        // Measure container and wrapper height
        /** @type {?} */
        var containerHeight = this.getContentBoxHeight(this._containerElement, true);
        /** @type {?} */
        var wrapperHeight = this._wrapperElement.offsetHeight;
        // Set top offset
        /** @type {?} */
        var topOffset = (wrapperHeight - containerHeight) * -1;
        this._initialTopOffset = (topOffset < this.customTopOffset) ?
            topOffset :
            this.customTopOffset;
        this._wrapperElement.style.top = this._initialTopOffset + 'px';
    };
    /**
     * Watches the scroll event and adjusts the "top" CSS property of the wrapper
     * element.
     */
    /**
     * Watches the scroll event and adjusts the "top" CSS property of the wrapper
     * element.
     * @return {?}
     */
    StickySidebarComponent.prototype.addScrollListener = /**
     * Watches the scroll event and adjusts the "top" CSS property of the wrapper
     * element.
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var scrollElement = (this._containerElement === document.documentElement) ?
            window :
            this._containerElement;
        scrollElement.addEventListener('scroll', (/**
         * @return {?}
         */
        function () {
            requestAnimationFrame((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var topOffset = parseInt(_this._wrapperElement.style.top);
                /** @type {?} */
                var newScrollTop = _this._containerElement.scrollTop;
                /** @type {?} */
                var scrollDistance = newScrollTop - _this._scrollTop;
                _this._scrollDirection = (scrollDistance > 0) ? 'down' : 'up';
                _this._scrollTop = _this._containerElement.scrollTop;
                if (_this._scrollDirection === 'down') {
                    if (topOffset - scrollDistance <= _this._initialTopOffset) {
                        _this._wrapperElement.style.top = _this._initialTopOffset + 'px';
                    }
                    else {
                        _this._wrapperElement.style.top =
                            (topOffset - scrollDistance) + 'px';
                    }
                }
                else {
                    if (topOffset - scrollDistance >= _this.customTopOffset) {
                        _this._wrapperElement.style.top = _this.customTopOffset + 'px';
                    }
                    else if (newScrollTop > -_this._initialTopOffset) {
                        _this._wrapperElement.style.top = (topOffset - scrollDistance) + 'px';
                    }
                }
            }));
        }));
    };
    /**
     * Watches the window.resize event and resets sidebar.
     */
    /**
     * Watches the window.resize event and resets sidebar.
     * @return {?}
     */
    StickySidebarComponent.prototype.addResizeListener = /**
     * Watches the window.resize event and resets sidebar.
     * @return {?}
     */
    function () {
        var _this = this;
        window.addEventListener('resize', (/**
         * @return {?}
         */
        function () {
            requestAnimationFrame((/**
             * @return {?}
             */
            function () { return _this.reset(); }));
        }));
    };
    /**
     * Returns the height of an element without padding or borders.
     * @param element The element to use.
     * @param limitToViewport Whether to use the full height or limit the height
     *                        to the height of the viewport.
     */
    /**
     * Returns the height of an element without padding or borders.
     * @param {?} element The element to use.
     * @param {?=} limitToViewport Whether to use the full height or limit the height
     *                        to the height of the viewport.
     * @return {?}
     */
    StickySidebarComponent.prototype.getContentBoxHeight = /**
     * Returns the height of an element without padding or borders.
     * @param {?} element The element to use.
     * @param {?=} limitToViewport Whether to use the full height or limit the height
     *                        to the height of the viewport.
     * @return {?}
     */
    function (element, limitToViewport) {
        if (limitToViewport === void 0) { limitToViewport = false; }
        /** @type {?} */
        var styles = getComputedStyle(element);
        /** @type {?} */
        var outerHeight = (limitToViewport) ?
            element.clientHeight :
            element.offsetHeight;
        /** @type {?} */
        var padding = parseInt(styles.paddingTop) +
            parseInt(styles.paddingBottom);
        /** @type {?} */
        var borders = parseInt(styles.borderTopWidth) +
            parseInt(styles.borderBottomWidth);
        /** @type {?} */
        var innerHeight = outerHeight - padding - borders;
        return innerHeight;
    };
    StickySidebarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'raven-sticky-sidebar',
                    template: "<div #wrapper class=\"ss-wrapper\"><ng-content></ng-content></div>",
                    styles: [".ss-wrapper{position:-webkit-sticky;position:sticky;top:0}"]
                }] }
    ];
    /** @nocollapse */
    StickySidebarComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    StickySidebarComponent.propDecorators = {
        customTopOffset: [{ type: Input, args: ['topOffset',] }],
        wrapperElementRef: [{ type: ViewChild, args: ['wrapper', { static: true },] }],
        containerSelector: [{ type: Input, args: ['container',] }]
    };
    return StickySidebarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var StickySidebarModule = /** @class */ (function () {
    function StickySidebarModule() {
    }
    StickySidebarModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [StickySidebarComponent],
                    imports: [],
                    exports: [StickySidebarComponent]
                },] }
    ];
    return StickySidebarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { StickySidebarComponent, StickySidebarModule, StickySidebarService };
//# sourceMappingURL=raven-sticky-sidebar.js.map
