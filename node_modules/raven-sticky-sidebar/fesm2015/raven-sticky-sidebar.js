import { Injectable, ɵɵdefineInjectable, Component, ElementRef, Input, ViewChild, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StickySidebarService {
    constructor() { }
}
StickySidebarService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
StickySidebarService.ctorParameters = () => [];
/** @nocollapse */ StickySidebarService.ngInjectableDef = ɵɵdefineInjectable({ factory: function StickySidebarService_Factory() { return new StickySidebarService(); }, token: StickySidebarService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StickySidebarComponent {
    /**
     * @param {?} _hostElementRef
     */
    constructor(_hostElementRef) {
        this._hostElementRef = _hostElementRef;
        this.customTopOffset = 0;
        this._containerElement = document.documentElement;
        this._scrollTop = 0;
        this._scrollDirection = 'down';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set containerSelector(value) {
        this._containerElement = document.querySelector(value);
        if (this._wrapperElement) {
            this.reset();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._wrapperElement = (/** @type {?} */ (this.wrapperElementRef.nativeElement));
        this.reset();
        this.addScrollListener();
        this.addResizeListener();
    }
    /**
     * Resets sidebar based on current conditions.
     * @return {?}
     */
    reset() {
        /** @type {?} */
        const hostElement = (/** @type {?} */ (this._hostElementRef.nativeElement));
        hostElement.style.minHeight = '0';
        this.setSidebarHeight();
        this.initTopOffset();
        this._scrollTop = this._containerElement.scrollTop;
    }
    /**
     * Ensures the minimum height of the sidebar is the same as the container
     * when floats are used.
     * @param {?=} height
     * @return {?}
     */
    setSidebarHeight(height) {
        /** @type {?} */
        const hostElement = (/** @type {?} */ (this._hostElementRef.nativeElement));
        if (getComputedStyle(hostElement).cssFloat === 'none') {
            return;
        }
        /** @type {?} */
        let containerHeight;
        if (height) {
            containerHeight = height;
        }
        else {
            containerHeight = (this._containerElement === document.documentElement) ?
                hostElement.parentElement.offsetHeight :
                this.getContentBoxHeight(this._containerElement);
        }
        hostElement.style.minHeight = containerHeight + 'px';
        if (this._containerElement !== document.documentElement) {
            // Height change may have changed container height
            /** @type {?} */
            const newContainerHeight = this.getContentBoxHeight(this._containerElement);
            if (hostElement.offsetHeight < newContainerHeight) {
                this.setSidebarHeight(newContainerHeight);
            }
        }
    }
    /**
     * Initializes the "top" CSS property of the wrapper element.
     * @return {?}
     */
    initTopOffset() {
        // Measure container and wrapper height
        /** @type {?} */
        const containerHeight = this.getContentBoxHeight(this._containerElement, true);
        /** @type {?} */
        const wrapperHeight = this._wrapperElement.offsetHeight;
        // Set top offset
        /** @type {?} */
        const topOffset = (wrapperHeight - containerHeight) * -1;
        this._initialTopOffset = (topOffset < this.customTopOffset) ?
            topOffset :
            this.customTopOffset;
        this._wrapperElement.style.top = this._initialTopOffset + 'px';
    }
    /**
     * Watches the scroll event and adjusts the "top" CSS property of the wrapper
     * element.
     * @return {?}
     */
    addScrollListener() {
        /** @type {?} */
        const scrollElement = (this._containerElement === document.documentElement) ?
            window :
            this._containerElement;
        scrollElement.addEventListener('scroll', (/**
         * @return {?}
         */
        () => {
            requestAnimationFrame((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const topOffset = parseInt(this._wrapperElement.style.top);
                /** @type {?} */
                const newScrollTop = this._containerElement.scrollTop;
                /** @type {?} */
                const scrollDistance = newScrollTop - this._scrollTop;
                this._scrollDirection = (scrollDistance > 0) ? 'down' : 'up';
                this._scrollTop = this._containerElement.scrollTop;
                if (this._scrollDirection === 'down') {
                    if (topOffset - scrollDistance <= this._initialTopOffset) {
                        this._wrapperElement.style.top = this._initialTopOffset + 'px';
                    }
                    else {
                        this._wrapperElement.style.top =
                            (topOffset - scrollDistance) + 'px';
                    }
                }
                else {
                    if (topOffset - scrollDistance >= this.customTopOffset) {
                        this._wrapperElement.style.top = this.customTopOffset + 'px';
                    }
                    else if (newScrollTop > -this._initialTopOffset) {
                        this._wrapperElement.style.top = (topOffset - scrollDistance) + 'px';
                    }
                }
            }));
        }));
    }
    /**
     * Watches the window.resize event and resets sidebar.
     * @return {?}
     */
    addResizeListener() {
        window.addEventListener('resize', (/**
         * @return {?}
         */
        () => {
            requestAnimationFrame((/**
             * @return {?}
             */
            () => this.reset()));
        }));
    }
    /**
     * Returns the height of an element without padding or borders.
     * @param {?} element The element to use.
     * @param {?=} limitToViewport Whether to use the full height or limit the height
     *                        to the height of the viewport.
     * @return {?}
     */
    getContentBoxHeight(element, limitToViewport = false) {
        /** @type {?} */
        const styles = getComputedStyle(element);
        /** @type {?} */
        const outerHeight = (limitToViewport) ?
            element.clientHeight :
            element.offsetHeight;
        /** @type {?} */
        const padding = parseInt(styles.paddingTop) +
            parseInt(styles.paddingBottom);
        /** @type {?} */
        const borders = parseInt(styles.borderTopWidth) +
            parseInt(styles.borderBottomWidth);
        /** @type {?} */
        const innerHeight = outerHeight - padding - borders;
        return innerHeight;
    }
}
StickySidebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'raven-sticky-sidebar',
                template: `<div #wrapper class="ss-wrapper"><ng-content></ng-content></div>`,
                styles: [".ss-wrapper{position:-webkit-sticky;position:sticky;top:0}"]
            }] }
];
/** @nocollapse */
StickySidebarComponent.ctorParameters = () => [
    { type: ElementRef }
];
StickySidebarComponent.propDecorators = {
    customTopOffset: [{ type: Input, args: ['topOffset',] }],
    wrapperElementRef: [{ type: ViewChild, args: ['wrapper', { static: true },] }],
    containerSelector: [{ type: Input, args: ['container',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StickySidebarModule {
}
StickySidebarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [StickySidebarComponent],
                imports: [],
                exports: [StickySidebarComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { StickySidebarComponent, StickySidebarModule, StickySidebarService };
//# sourceMappingURL=raven-sticky-sidebar.js.map
